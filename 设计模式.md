### 闭包

#### 缓存

```javascript
var mult = (function(){
  var cache = {};
  var calculate = function() { // 封闭calculate函数
    var a = 1;
    for (var i = 0, l = arguments.length; i < l; i++) {
      a = a * arguments[i];
    }
    return a;
  };
  
  return function() {
    var args = Array.prototype.join.call( arguments, ',');
    if ( args in cache ) {
      return cache[args];
    } 
    return cache[args] = calculate.apply(null, arguments);
  }
})();
```

#### 延迟局部变量的寿命

```javascript
var report = (function() {
  var imgs =[];
  return function (src) {
    var img = new Image();
    imgs.push(img);
    img.src = src;
  }
})();
```

#### 闭包和面向对象

```javascript
var extent = function() {
  var value = 0;
  return {
    call: function () {
      value++;
      console.log(value);
    }
  }
};
var extent = extent();
extent.call(); // 输出: 1
extent.call(); // 输出: 2
extent.call(); // 输出: 3
```

#### 用闭包实现命令模式

```javascript
var Tv = {
  open: function() {
    console.log('打开电视机');
  },
  close: function() {
    console.log('关闭电视机');
  }
}

var createCommand = function (receiver) {
  var execute = function() {
    return receiver.open(); // 执行命令，打开电视机
  }
  
  var undo = function() {
    return receiver.close(); // 执行命令，关闭电视
  }
  
  return {
    execute: execute,
    undo: undo
  }
};

var setCommand = function( command ) {
  document.getElemntById('execute').onClick = function() {
    command.execute(); // 输出：打开电视机
  }
  document.getElemntById('undo').onClick = function() {
    command.undo(); // 输出：关闭电视机
  }
}

setCommand( createCommand( Tv ));
```

#### 判断数据的类型

```javascript
var Type = {};

for (var i = 0, type; type = ['String', 'Array', 'Mumber'][i++];) {
  Type['is' + type] = function( obj ){
      (function( type ) {
        Type['is' + type] = function( obj ) {
          return Object.prototype.toString.call(obj) === '[object ' + type + ']';
        } 
      })(type)
    }
};

Type.isArray([]); // true
Type.isString("str"); // true
```

#### 高阶函数实现AOP

AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计功能模块。

```javascript
Function.prototype.before = function(beforefn) {
  var __self = this; // 保存原函数的引用
  return function() { // 返回包含了原函数和新函数的“代理”函数
    beforefn.apply(this, arguments); // 执行新函数，修正this
    return __self.apply(this.arguments); // 执行原函数
  }
};

Function.prototype.after = function(afterfn) {
  var __self = this;
  return function() {
    var ret = __self.apply(this, arguments);
    afterfn.apply(this, arguments);
    return ret;
  }
}

var func = function() {
  console.log(2);
}

func = func.before(function() {
  console.log(1);
}).after(function(){
  console.log(3);
});

func();
```

#### 高阶函数的其他应用

##### 1.currying

```javascript
var cost = (function() {
  var args = [];
  
  return function() {
    if (arguments.length === 0) {
      var money = 0;
      for (var i = 0, l = args.length; i < l; i++) {
        money += args[i]
      }
      return money;
    } else {
      [].push.apply(args, arguments);
    }
  }
})();

cost(100);
cost(200);
cost(300);

cost() // 600
```

curry化函数

```javascript
var currying = function(fn) {
  var args = [];
  
  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, apply);
    } else {
      [].push.apply(args, arguments);
      return arguments.callee;
    }
  }
};

var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = curry(cost);

cost(100);
cost(200);
cost(300);

cost() // 600
```

#### 2.uncurrying

```javascript
Function.prototype.uncurrying = function() {
  var self = this;
  return function() {
    var obj = Array.prototype.shift.call(arguments);
    return self.apply(obj, arguments);
  }
}
```

例子

```javascript
for (var i = 0, fn, ary = ['push', 'shift', 'forEach']; fn = ary[i++];) {
  Array[fn] = Array.prototype[fn].uncurrying();
}

var obj = {
  "length": 3,
  "0": 1,
  "1": 2,
  "2": 3
};

Array.push(obj, 4);
console.log(obj.length);

var first = Array.shift(obj);
console.log(first);
console.log(obj);

Array.forEach(obj, function(i, n) {
  console.log(n); // 分别输出: 0, 1, 2
})
```

#### 3.函数节流

```javascript
var throttle = function(fn, interval) {
  var __self = fn, // 保存需要被延迟执行的函数引用
      timer, // 定时器
      firstTime = true; // 是否是第一次调用
  
  return function() {
    var args = arguments,
        __me = this;
    
    if (firstTime) { // 如果是第一次调用，不需延迟执行
      __self.apply(__me, args);
      return firstTime = false;
    }
    
    if ( timer ) { // 如果定时器还在，说明前一次延迟执行还没有完成
      return false;
    }
    
    timer = setTimeout(function() { // 延迟一段时间执行
      clearTimeout(timer);
      timer = null;
      __self.apply(__me, args);
    }, interval || 500);
  };
};


window.onresize = throttle(function() {
  console.log(1)
}, 500)
```

#### 4.分时函数

分批，分时执行 

```javascript
var timeChunk = function(ary, fn, count) {
  var obj, t;
  var len = ary.length;
  
  var start = function() {
    for(var i = 0; i < Math.min(count || 1, ary.length ); i++) {
      var obj = ary.shift();
      fn( obj );
    }
  };
  
  return function() {
    t = setInterval(function() {
      if (ary.length === 0) { // 如果全部节点都已经被创建好
        return clearInterval( t );
      }
      start();
    }, 200); // 分批执行的时间间隔，也可以用参数的形式传入
  };
};
```

#### 5.惰性加载函数

```javascript
var addEvent = function( elem, type, handler) {
  if ( window.addEventListener ) {
    addEvent = function(elem, type, handler) {
      elem.addEventListener(type, handler, false);
    }
  } else if ( window.attachEvent ) {
    addEvent = function( elem, type, handler) {
      elem.attachEvent('on' + type, handler)
    }
  }
  addEvent(elem, type, handler);
}

var div = documentt.getElementById('div1');

addEvent(div, 'click', function() {
  alert(1);
});

addEvemt(div, 'click', function() {
  alert(2);
});
```

## 设计模式

### 单例模式

单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

应用场景：线程池、全局缓存、浏览器中的window对象、浮窗。

```javascript
var Singleton = function (name) {
  this.name = name;
}

Singleton.instance = null;
Singleton.prototype.getName = function() {
  alert(this.name);
}

Singleton.getInstance = function(name) {
  if ( !this.instance ) {
    this.instance = new Singleton(name);
  }
  return this.instance
}

var a = Singleton.getInstance('sven1');
var b = Singleton.getInstance('sven2');

alert( a === b ); // true

// 或者
var Singleton = function(name) {
  this.name = name;
}

Singleton.prototype.getName = function() {
  alert( this.name )
}

Singleton.getInstance = (function() {
  var instance = null;
  return function( name ) {
    if ( !instance ) {
      instance = new Singleton(name);
    }
    return instance;
  }
})();

var a = Singleton.getInstance('sven1');
var b = Singleton.getInstance('sven2');

alert( a === b ); // true
```

#### 透明的单例模式

```javascript
var CreateDiv = (function () {
  var instance;
  
  var CreateDiv = function ( html ) {
    if ( instance ) {
      return instance
    }
    this.html = html
    this.init();
    return instance = this;
  };
  
  CreateDiv.prototype.init = function() {
    var div = document.createElement('div');
    div.innerHTML = this.html;
    document.body.appendChild(div);
  };
  
  return CreateDiv;
})();

var a = new CreateDiv('sven1');
var b = new CreateDiv('sven2');

alert( a === b ); // true
```

#### 用代理实现单例模式

```javascript
var CreateDiv = function( html ) {
  this.html = html;
  this.init();
}

CreateDiv.prototype.init = function() {
  var div = document.createElement('div');
  div.innerHTML = this.html;
  document.body.appendChild(div);
}

var ProxySingletonCreateDiv = (function() {
  
  var instance;
  return function( html ) {
    if ( !instance ) {
      instance = new CreateDiv(html);
    }
    return instance;
  }
})();

var a = new ProxySingletonCreateDiv( 'sven1' );
var b = new ProxySingletonCreateDiv( 'sven2' );

alert( a === b );
```

#### Javascript中的单例模式

全局变量符合这个单例模式

但是我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。

##### 1.使用命名空间

```javascript
var namespace1 = {
  a: function() {
    alert(1);
  },
  b: function() {
    alert(2);
  }
}
```

##### 动态创建命名空间

```javascript
var MyApp = {};

MyApp.namespace = function( name ) {
  var parts = name.split('.');
  var current = MyApp;
  for( var i in parts) {
    if ( !current[ parts[i] ] ) {
      current[ parts[ i ]] = {}
    }
    current = current[ parts[ i ] ];
  }
};

MyApp.namespace('event');
MyApp.namespace('dom.style');

console.dir( MyApp );

// 上述代码等价于:

var MyApp = {
  event: {},
  dom: {
    style: {}
  }
}
```

##### 2.使用闭包封装私有变量

```javascript
var user = (function() {
  var __name = 'sven',
      __age = 29;
  
  return {
    getUserInfo: function() {
      return __name + '-' + __age
    }
  }
})
```

#### 惰性单例

instance实例对象总是在我们调用Singleton.getInstance的时候才被创建，而不是在页面加载好的时候就创建。

```javascript
Singleton.getInstance = (function() {
  var instance = null;
  return function( name ) {
    if ( !instance ) {
      instance = new Singleton( name );
    }
    return instance;
  }
})
```

#### 通用的惰性单例

```javascript
var createIframe = (function() {
  var iframe;
  return function() {
    if (!iframe) {
      iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      document.body.appendChild(iframe);
    }
    return iframe;
  }
})
```

抽离

```javascript
var getSingle = function(fn) {
  var result;
  return function() {
    return result || (result = fn.apply(this, arguments));
  }
}
```

例子

```javascript
var createLoginLayer = function () {
  var div = document.createElement('div');
  div.innerHTML = '我是登录浮窗';
  div.style.display = 'none';
  document.body.appendChild(div);
}

var createSingleLoginLayer = getSingle(createLoginLayer);

document.getElementById('loginBtn').onClick = function() {
  var loginLayer = createSingleLoginLayer();
  loginLayer.style.display = 'block';
}
```

### 策略模式

策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。

一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。

```javascript
var performanceS  = function(){};

performanceS.prototype.calculate = function( salary ) {
  return salary * 4;
}

var performanceA = function(){};

performanceA.prototype.calculate = function( salary ) {
  return salary * 3;
}

var performanceB = function(){};

performanceB.prototype.calculate = function( salary ) {
  return salary * 2;
}

var Bonus = function() {
  this.salary = null;
  this.strategy = null;
};

Bouns.prototype.setSalary = function( salary ) {
  this.salary = salary; 
}

Bouns.prototype.setStrategy = function( strategy ) {
  this.strategy = strategy;
}

Bouns.prototype.getBouns = function() {
  if (!this.strategy) {
    throw new Error('未设置strategy属性');
  }
  return this.strategy.calculate(this.salary);
}

var bouns = new Bouns();

bouns.setSalary( 10000 );
bouns.setStrategy( new performanceS() );

console.log(bouns.getBouns()); // 40000

bouns.setStrategy( new performanceA() );
console.log(bouns.getBouns()); // 30000
```

javascript版本的策略模式

```javascript
var strategies = {
  "S": function( salary ) {
    return salary * 4;
  },
  "A": function( salary ) {
    return salary * 3;
  },
  "B": function( salary ) {
    return salary * 2;
  }
}

var calculateBouns = function( level, salary ){
  return strategies[ level ]( salary );
}

console.log( calculateBouns('S', 20000)); // 80000
console.log( calculateBouns('A', 10000)); // 30000
```

策略模式---动画应用

```javascript
var tween = {
  linear: function( t, b, c, d) {
    return c*t/d + b;
  },
  easeIn: function( t, b, c, d) {
    return c * ( t /= d) * t + b;
  },
  strongEaseIn: function( t, b, c, d) {
    return c * ( t /= d) * t * t * t * t + b;
  },
  strongEaseOut: function( t, b, c, d) {
    return c * (( t = t / d - 1) * t * t * t * t + 1) + b;
  },
  sineaseIn: function( t, b, c, d) {
    return c * ( t / = d) * t * t + b;
  },
  sineaseOut: function( t, b, c, d) {
    return c * (( t = t / d - 1) * t * t + 1) + b;
  }
}
```

```html
<body>
  <div style="position: absolute; background:blue" id="div">
    我是div
  </div>
</body>
```

```javascript
var Animate = function(dom) {
  this.dom = dom;
  this.startTime = 0;
  this.startPos = 0;
  this.endPos = 0;
  this.propertyName = null;
  this.easing = null;
  this.duration = null;
}

Animate.prototype.start = function(propertyName, endPos, duration, easing) {
  this.startTime = +new Date;
  this.stratPos = this.dom.getBoundingClientRect()[propertyName];
  this.propertyName = propertyName;
  this.endPos = endPos;
  this.duration = duration;
  this.easing = tween[ easing ];
  
  var self = this;
  var timeId = setInterval(function() {
    if ( self.step() === false) {
      clearInterval(timeId);
    }
  }, 19)
}

Animate.prototype.step = function() {
  var t = +new Date;
  if ( t >= this.startTime + this.duration ) {
    this.update( this.endPos );
    return false;
  }
  var pos = this.easing( t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration );
  this.update(pos);
}

Animate.prototype.update = function(pos) {
  this.dom.style[ this.propertyName] = pos + 'px'
}

var div = document.getElementById('div');
var animate = new Animate(div);

animate.start('left', 500, 1000,, 'strongEaseOut')
```

用策略模式重构表单校验

```javascript
var strategies = {
  isNonEmpty: function(value, errorMsg) { // 不为空
    if (value === '') {
      return errorMsg;
    }
  },
  minLength: function(value, length, errorMsg) { // 限制最小长度
    if (value.length < length) {
      return errorMsg;
    }
  },
  isMobile: function(value, errorMsg) { // 手机号码格式
    if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) {
      return errorMsg;
    }
  }
};

var Validator = function() {
  this.cache = []; // 保存校验规则
}

Validator.prototype.add = function( dom, rule, errorMsg) {
  var ary = rule.split(':'); // 把strategy和参数分开
  this.cache.push(function() { // 把校验的步骤用空函数包装起来，并且放入cache
    var strategy = ary.shift(); // 用户挑选的strategy
    ary.unshift( dom.value ); // 把input的value添加进参数列表
    ary.push( errorMsg ); // 把errorMsg添加进参数列表
    return startegies[strategy].apply(dom, ary);
  });
};

Validator.prototype.start = function() {
  for (var i = 0, validatorFunc; validatorFunc = this.cache[ i++ ];) {
    var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息
    if (msg) { // 如果有确切的返回值，说明校验没有通过
      return msg
    }
  }
}

var vlidataFunc = function() {
  var validator = new Validator(); // 创建一个 validator 对象
  
  /***************添加一些校验规则**************/
  validator.add( registerForm.userName, 'isNonEmpty', '用户名不能为空');
  validator.add( registerForm.password, 'minLength: 6', '密码长度不能少于6位');
  validator.add( registerForm.phoneNumber. 'isMobile', '手机号码格式不正确');
  
  var errorMsg = validator.start(); // 获得校验结果
  return  errorMsg; // 返回校验结果
}

var registerForm = document.getElementById('registerForm');
registerForm.onsubmit = function() {
  var errorMsg = validataFunc();
  if ( errorMsg ) {
    alert( errorMsg );
    return false; // 阻止表单提交
  }
}
```

#### 策略模式的优缺点

优点：

1.策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。

2.策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展。

3.策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的肤质粘贴工作。

4.在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案

缺点：

1.使用策略模式回在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context中要好。

2.要使用策略模式必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。

### 代理模式

代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。

#### 保护代理和虚拟代理

虚拟代理实现图片预加载

```javascript
var myImage = (function() {
  var imgNode = document.createElement('img');
  document.body.appendChild(imgNode);
  
  return {
    setSrc: function(src) {
      imgNode.src = src
    }
  }
})();

// 在真正的图片加载好之前，先把img节点的src设置为一张本地的loading图片。
var proxyImage = (function() {
  var img = new Image;
  img.onload = function() {
    myImage.setSrc( this.src );
  }
  
  return {
    setSrc: function(src) {
      myImage.setSrc('file: // /C: /Users/svenzeng/Desktop/loading.gif');
      img.src = src;
    }
  }
})();

proxyImage.setSrc('http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg');
```

面向对象设计的原则-----单一职责原则。

单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。

#### 代理和本体接口的一致性

好处：

1.用户可以放心地请求代理，他只关心是否能得到想要的结果。

2.在任何使用本体的地方都可以替换成使用代理。

#### 虚拟代理合并HTTP请求

```javascript
var synchronousFile = function( id ) {
  console.log('开始同步文件，id为:' + id);
}

var proxySynchronousFuke = (function() {
  var cache = [], // 保存一段时间内需要同步的ID
      timer; // 定时器
  
  return function(id) {
    cache.push(id);
    if (timer) {
      return;
    }
    
    timer = setTimeout(function() {
      synchronousFile(cache.join(',')); // 2秒后向本体发送需要同步的ID集合
      clearTimeout(timer); // 清空定时器
      timer = null;
      cache.length = 0; //清空ID集合
    }, 2000);
  }
})();

var checkbox = document.getElementsByTagName('input');

for( var i = 0, c; c = checkbox[i++];) {
  c.onclick = function(){
    if (this.checked === true) {
      proxySynchronousFile( this.id )
    }
  }
}
```

#### 虚拟代理在惰性加载中的应用

未加载真正的miniConsole.js之前的代码如下：

```javascript
var cache = []

var miniConsole = {
  log: function() {
    var args = arguments;
    cache.push(function() {
      return miniConsole.log.apply(miniConsole, args)
    })
  }
}

miniConsole.log(1);
```

当用户按下F2时，开始加载真正的miniConsole.js，代码如下:

```javascript
var handler = function(ev) {
  if (ev.keyCode === 113) {
    var script = document.createElement('script');
    script.onload = function() {
      for( var i = 0, fn; fn = cache[i++];) {
        fn();
      }
    };
    script.src = 'miniConsole.js';
    document.getElementsByTagName('head')[0].appendChild(script);
  }
};

document.body.addEventListener('keydown', handler, false);

// miniConsole.js 代码:

miniConsole = {
  log: function() {
    // 真正代码略
    console.log(Array.prototype.join.call( arguments ));
  }
}
```

整理版：

```javascript
var miniConsole = (function(){
  var cache = [];
  var handler = function( ev ) {
    if ( ev.keyCode === 113 ) {
      var script = document.createElement('script');
      script.onload = function() {
        for (var i = 0, fn; fn = cache[i++]) {
          fn();
        }
      };
      script.src = 'miniConsole.js';
      document.getELementsByTagName('head')[0].appendChild(script);
      document.body.removeEventListener('keydown', handler); // 只加载一次miniConsole.js
    }
  };
  
  document.body.addEventListener('keydown', handler, false);
  
  return {
    log: function() {
      var args = arguments;
      	cache.push(function() {
          return miniConsole.log.apply(miniConsole, args);
        });
    }
  }
})();

miniConsole.log(11); // 开始打印log

// miniConsole.js代码

miniConsole = {
  log: function() {
    // 真正代码略
    console.log(Array.prototype.join.call( arguments ));
  }
}
```

#### 缓存代理

```javascript
var mult = function() {
  console.log('开始计算乘积')；
  var a = 1;
  for( var i = 0, l = arguments.length; i < l; i++) {
    a = a* arguments[i];
  }
  return a;
}

mult(2, 3); // 6
mult(2, 3, 4); // 24

var proxyMult = (function() {
  var cache = {};
  return function() {
    var args = Array.prototype.join.call(arguments, ',');
    if ( args in cache ) {
      return cache[ args ];
    }
    return cache[ args ] = mult.apply(this, arguments)
  }
})();

proxyMult( 1, 2, 3, 4); // 24
proxyMult( 1, 2, 3, 4); // 24
```

缓存代理可以应用在ajax异步请求数据

#### 用高阶函数动态创建代理

```javascript
/*************计算乘积****************/
var mult = function() {
  var a = 1;
  for (var i = 0, l = arguments.length; i < 1; i++) {
    a = a * arguments[i];
  }
  return a;
}

/*************计算加和****************/
var plus = function() {
  var a = 0;
  for (var i = 0, l = arguments.length; i < l; i++) {
    a = a + arguments[i];
  }
  return a;
}

/*************创建缓存代理的工厂****************/
var createProxyFactory = function( fn ) {
  var cache = {};
  return function() {
    var args = Array.prototype.join.call(arguments, ',');
    if ( args in cache) {
      return cache[args];
    }
    return cache[args] = fn.apply(this, arguments);
  }
};

var proxyMult = createProxyFactory(mult),
    proxyPlus = createProxyFactory(plus);

alert( proxtMult(1, 2, 3, 4)); // 24
alert( proxtMult(1, 2, 3, 4)); // 24
alert( proxtPlus(1, 2, 3, 4)); // 10
alert( proxtPlus(1, 2, 3, 4)); // 10
```

#### 其他代理模式

1.防火墙代理: 控制网络资源的访问，保护主机不让"坏人"接近。

2.远程代理: 为一个对象在不同的地址空间提供局部代表，在Java中，远程代理可以是另一个虚拟机中的对象。

3.保护代理: 用于对象应该有不同访问权限的情况。

4.智能引用代理: 取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。

5.写时复制代理:  通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL是其典型的运用场景。

#### 小结

在Javascript开发中经常需要用到的是虚拟代理和缓存代理。

### 迭代器模式

迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按照顺序访问其中的每个元素。

#### 内部迭代器和外部迭代器

##### 1.内部迭代器

```javascript
var each = function(ary, callback) {
  for (var i = 0, l = ary.length; i < l; i++){
    callback.call(ary[i], i, ary[i]); // 把下标和元素当作参数传给callback函数
  }
}

each([1,2,3], function(i, n) {
  alert([i,n]);
})

var compare = function( ary1, ary2 ) {
  if ( ary1.length !== ary2.length ) {
    throw new Error('ary1 和 ary2 不相等');
  }
  each( ary1, function( i, n) {
    if (n !== ary2[i]) {
      throw new Error('ary1 和 ary2不相等');
    }
  })
  alert('ary1 和 ary2 相等');
}

compare([1, 2, 3], [ 1, 2, 4]); // throw new Error('ary1 和 ary2 不相等');
```

##### 2.外部迭代器

外部迭代器必须显式地请求迭代下一个元素。

外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。

```javascript
var Iterator = function( obj ) {
  var current = 0;
  
  var next = function() {
    current += 1;
  }
  
  var isDone = function() {
    return current >= obj.length;
  }
  
  var getCurrItem = function() {
    return obj[current];
  }
  
  return {
    next: next,
    isDone: isDone,
    getCurrItem: getCurrItem,
    length: obj.length
  }
};

var compare = function(iterator1, iterator2) {
  if(iterator1.length !== iterator2.length) {
    alert('iterator1 和 iterator2 不相等');
  }
  while( !iterator1.isDone() && !iterator2.isDone()){
    if (iterator1.getCurrItem() !== iterator2.getCurrItem()) {
      throw new Error('iterator1 和 iterator2 不相等');
    }
    iterator1.next();
    iterator2.next();
  }
  alert( 'iterator1 和 iterator2 相等')
}

var iterator1 = Iterator([1, 2, 3]);
var iterator2 = Iterator([1, 2, 3]);

compare( iterator1, iterator2 ); // 输出: iterator1 和 iterator2 相等。
```

#### 迭代类数组对象和字面量对象

```javascript
$.each = function(obj, callback) {
  var value,
      i = 0,
      length = obj.length,
      isArray = isArraylike( obj );
  
  if ( isArray ) { // 迭代类数组
    for ( ; i < length; i++) {
      value = callback.call( obj[ i ], i, obj[ i ]);
      
      if ( value === false ) {
        break;
      }
    }
  } else {
    for (i in obj) {
      value = callback.call(obj[i], i, obj[ i ]);
      if (value === false) {
        break;
      }
    }
  }
  return obj;
}
```

#### 倒序迭代器

```javascript
var reverseEach = function(ary, callback) {
  for (var l = ary.length - 1; l >= 0; l--) {
    callback(1, ary[ l ]);
  }
};

reverseEach([ 0, 1, 2], function( i, n) {
  console.log(n); // 2, 1, 0
})
```

#### 中止迭代器

```javascript
if (value === false) {
  break;
}

var each = function ( ary, callback ) {
  for (var i = 0, l = ary.length; i < l; i++) {
    if (callback(i, ary[ i ]) === false ) { // callback的执行结果返回false，提前中止迭代。
      break;
    }
  }
};

each([ 1, 2, 3, 4, 5], function(i, n) {
  if (n > 3) { // n大于3的时候中止循环
    return false;
  }
  console.log( n ); // 1, 2, 3
})
```

#### 迭代器模式的应用举例

根据不同的浏览器获取相应的上传组件对象：

```javascript
var getActiveUploadObj = function() {
  try {
    return new ActiveXObject( "TXFTNActiveX.FTNUpload" ); // IE上传控件
  } catch(e) {
    return false
  }
};

var getFlashUploadObj = function() {
  if (supportFlash()) { // supportFlash函数未提供
    var str = '<object type="application/x-shockwave-flash"></object>';
    return $( str ).appendTo( $('body'));
  }
  return false;
}

var getFormUploadObj = function() {
  var str = '<input name="file" type="file" class="ui-file" />'; // 表单上传
  return $( str ).appendTo($('body'))
}

var iteratorUploadObj = function() {
  for (var i = 0, fn; fn = arguments[i++]) {
    var uploadObj = fn();
    if ( uploadObj !== flase ) {
      return uploadObj;
    }
  }
};

var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUploadObj);
```

### 发布-订阅模式

发布-订阅模式又叫观察者模式，它定义对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。

在javascript开发中，我们一般用事件模型来替代传统的发布-订阅模式。

#### 自定义事件

```javascript
var salesOffices = {}; // 定义售楼处

salesOffices.clientList = []; // 缓存列表，存放订阅者的回调函数

salesOffices.listen = function(fn) { // 增加订阅者
  this.clientList.push(fn);  // 订阅的消息添加进缓存列表
} 

salesOffices.trigger = function() { // 发布消息
  for(var i =  0, fn; fn = this.clientList[ i++ ];) {
    fn.apply(this, arguments);
  }
};


//测试
// 新增1
salesOffices.listen(function(price, squareMeter) {
  console.log('价格=' + price)；
  console.log('squareMeter=' + squareMeter);
})

// 新增2
salesOffices.listen(function(price, squareMeter) {
  console.log('价格=' + price)；
  console.log('squareMeter=' + squareMeter);
})

salesOffices.trigger(2000000, 88);
salesOffices.trigger(3000000, 110);
```

改良版本：

```javascript
var salesOffices = {}; // 定义售楼处

salesOffices.clientList = {}; // 缓存列表，存放订阅者的回调函数

salesOffices.listen = function(fn) { // 增加订阅者
  if (!this.clientList[key]) { //如果还没有订阅过此类消息，给该消息创建一个缓存列表
    this.clientList[key] = [];
  }
  this.clientList[key].push(fn); // 订阅的消息添加进消息缓存列表
} 

salesOffices.trigger = function() { // 发布消息
  var key = Array.prototype.shift.call(arguments), // 取出消息类型
      fns = this.clientList[ key ] = []; // 取出该消息对应的回调函数集合
  
  if (!fns || fns.length === 0) { // 如果没有订阅该消息，则返回
    return false;
  }
  
  for (var i = 0, fn; fn = fns[i++];) {
    fn.apply(this, arguments); // (2) // arguments是发布消息时附送的参数
  }
  
};


//测试
// 新增1
salesOffices.listen(‘squareMeter88’， function(price) {
  console.log('价格=' + price)；
  console.log('squareMeter=' + squareMeter);
})

// 新增2
salesOffices.listen(‘squareMeter110’, function(price) {
  console.log('价格=' + price)；
})

salesOffices.trigger(‘squareMeter88’, 20000000);
salesOffices.trigger(‘squareMeter110’, 30000000;
```

改良后的版本，只给需要哪种类型消息的人发送特定消息。

增加动态职责功能：

```javascript
var event = {
  clientList: {},
  listen: function(key, fn) {
    if (!this.clientList[key]) { //如果还没有订阅过此类消息，给该消息创建一个缓存列表
      this.clientList[key] = [];
    }
  	this.clientList[key].push(fn); // 订阅的消息添加进消息缓存列表
  },
  trigger: function() {
    var key = Array.prototype.shift.call(arguments), // 取出消息类型
      fns = this.clientList[ key ] = []; // 取出该消息对应的回调函数集合
  
    if (!fns || fns.length === 0) { // 如果没有订阅该消息，则返回
      return false;
    }

    for (var i = 0, fn; fn = fns[i++];) {
      fn.apply(this, arguments); // (2) // arguments是发布消息时附送的参数
    }
  }
};

//定义一个installEvent函数，这个函数可以给所有的对象都动态安装发布-订阅功能
var installEvent = function(obj) {
  for (var i in event) {
    obj[i] = event[i]
  }
}

// 测试
// 新增1
salesOffices.listen(‘squareMeter88’， function(price) {
  console.log('价格=' + price)；
  console.log('squareMeter=' + squareMeter);
})

// 新增2
salesOffices.listen(‘squareMeter110’, function(price) {
  console.log('价格=' + price)；
})

salesOffices.trigger(‘squareMeter88’, 20000000);
salesOffices.trigger(‘squareMeter110’, 30000000;
```

#### 取消订阅的事件

```javascript
event.remove = function (key, fn) {
  var fns = this.clientList[key];
  
  if (!fn) {  // 如果key对应的消息没有被人订阅，则直接返回
    return false;
  }
  
  if (!fn) { // 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅
    fns && (fns.length = 0);
  } else {
    for (var l = fns.length - 1; l >= 0; l--) {
      var _fn = fns[l];
      if (_fn === fn) {
        fns.splice(l, 1)
      }
    }
  }
}
```

#### 中介者

```javascript
var Event = (function () {
  var clientList = {},
      listen,
      trigger,
      remove;
  
  listen = function (key, fn) {
    if (!clientList[key]) {
      clientList[key] = [];
    }
    clientList[key].push(fn);
  };
  
  trigger = function() {
    var key = Array.prototype.shift.call(arguments),
        fns = clientList[key];
    if (!fns || fns.length === 0) {
      return false;
    }
    for (var i = 0, fn; fn = fns[i++];) {
      fn.apply(this, arguments);
    } 
  };
  
  remove = function( key, fn) {
    var fns = clientList[key];
    if (!fns) {
      return false;
    }
    if (!fn) {
      fns&& (fns.length = 0);
    } else {
      for (var l = fns.length - 1; l >= 0; l--) {
        var _fn = fns[l];
        if (_fn == fn) {
          fns.splice(l, 1);
        }
      }
    }
  };
  
  return {
    listen,
    trigger,
    remove
  }
})();
```

#### 必须先订阅再发布吗？

可以先建立一个离线的堆栈。

#### 全局事件的命名冲突

可以使用命名空间

```javascript
var Event = (function() {
  var global = this,
      Event,
      _default = 'default';
  
  Event = function() {
    var _listen,
        _trigger,
        _slice = Array.prototype.slice,
        _shift = Array.prototype.shift,
        _unshift = Array.prototype.unshift,
        namespaceCache =  {},
        _create,
        find,
        each = function(ary, fn) {
          var ret;
          for (var i = 0, l = ary.length; i < l; i++) {
            var n = ary[i];
            ret = fn.call(n, i, n);
          }
          return ret;
        };
    
    _listen = function( key, fn, cache) {
      if (!cache[key]) {
        cache[key] = []
      }
      cache[key].push(fn);
    };
    
    _remove = function(key, cache, fn) {
      if (cache[key]) {
        if (fn) {
          for (var i = cache[key].length; i >= 0; i--) {
            if (cache[key][i] === fn) {
              cache[key].splice(i, 1);
            }
          }
        } else {
          cache[key] = [];
        }
      }
    };
    
    _trigger = function() {
      var cache = _shift.call(arguments),
          key = _shift.call(arguments),
          args = arguments,
          _self = this,
          ret,
          stack = cache[key];
      
      if ( !stack || !stack.length) {
        return;
      }
      
      return each(stack, function() {
        return this.apply(_self, args);
      });
    };
    
    _create = function(namespace) {
      var namespace = namespace || _default;
      var cache = {},
          offlineStatck = [],  // 离线事件
          ret = {
            listen: function(key, fn, last) {
              _listen(key, fn, cache);
              if (offlineStack === null) {
                return;
              }
              if (last === 'last') {
                offlineStack.length & offlineStack.pop()();
              } else {
                each( offlineStack, function() {
                  this();
                });
              }
              offlineStack = null;
            },
            one: function(key, fn, last) {
              _remove(key, cache);
              this.listen(key, cache, fn);
            },
            remove: function(key, fn) {
              _remove(key, cache, fn);
            },
            trigger: function() {
              var fn,
                  args,
                  _self = this;
              
              _unshift.call(argument, cache);
              args = arguments;
              fn = function() {
                return _trigger.apply(_self, args);
              };
              
              if (offlinestack) {
                return offlineStack.push(fn);
              }
              return fn();
            }
          };
      return {
        create: _create,
        one: function(key, fn, last) {
          var event = this.create();
          event.one(key, fn, last);
        },
        remove: function(key, fn) {
          var event = this.create();
          event.remove(key, fn);
        },
        listen: function(key, fn, last) {
          var event = this.create();
          event.listen(key, fn, last);
        },
        trigger: function() {
          var event = this.create();
          event.trigger.apply(this, arguments);
        }
      }
    }()
    return Event;
})()
```

发布订阅模式

1.为时间上的解耦

2.为对象上的解耦



但是需要消耗一定的时间和内存。

如果过度使用的话，对象和对象之间的必要联 系也将被深埋在背后，会导致程序难以跟踪维护和理解。

### 命令模式

命令模式最常见的应用场景是:有时候需要向某些对象发送请求，但是并不知道请求的接收 者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

相对于过程化的请求调用，command 对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在了 command 对象的方法中，成为了这个对象的行为。 我们可以在程序运行的任意时刻去调用这个方法，就像厨师可以在客人预定 1 个小时之后才帮他 炒菜，相当于程序在 1 个小时之后才开始执行 command 对象的方法。

#### 菜单程序

设计模式的主题总是把不变的事物和变化的事物分离开来。

模拟面向对象

```html
<body>
  <button id="button1">
    点击按钮1
  </button>
  <button id="button2">
    点击按钮2
  </button>
  <button id="button3">
    点击按钮3
  </button>
  <button id="button4">
    点击按钮4
  </button>
</body>
<script>
  var button1 = document.getElementById('button1')
  var button2 = document.getElementById('button2')
  var button3 = document.getElementById('button3')
</script>
```

```javascript
var setCommand = function( button, command ) {
  button.onclick  = function() {
    command.execute();
  }
}
```

```javascript
var RefreshMenuBarCommand = function (receiver) {
  this.receiver = receiver;
}

RefreshMenuBarCommand.prototype.execute = function() {
  this.receiver.refresh();
}

var AddSubMenuCommand = function (receiver) {
  this.receiver = receiver;
}

AddSubMenuCommand.prototype.execute = function() {
  this.receiver.add()
}

var DelSubMenuCommand = function(receiver) {
  this.receiver = receiver;
}

DelSubMenuCommand.prototype.execute = function() {
  console.log('删除子菜单')
}
```

```javascript
var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);
var addSubMenuCommand = new AddSubMenuCommand(SubMenu);
var delSubMenuCommand = new DelSubMenuCommand(SubMenu);

setCommand(button1, refreshMenuBarCommand);
setCommand(button2, addSubMenuCommand);
setCommand(button3, delSubMenuCommand);
```

#### JavaScript中的命令模式

js简单实现：

```javascript
var bindClick = function(button, func) {
  button.onclick = func;
}

var MenuBar = {
  refresh: function() {
    console.log('刷新菜单界面')
  },
}

var SubMenu = {
  add: function() {
    console.log('增加子菜单');
  },
  del: function() {
    console.log('删除子菜单');
  }
};

bindClick(button1, MenuBar.refresh);
bindClick(button2, MenuBar.add);
bindClick(button3, MenuBar.del);
```

```javascript
var setCommand = function(button, func) {
  button.onclick = function() {
    func();
  }
};

var MenuBar = {
  refresh: function() {
    console.log('刷新菜单界面');
  }
}

var RefreshMenuBarCommand = function(receiver) {
  return function() {
    receiver.refresh();
  }
}

var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);

setCommand(button1, refreshMenuBarCommand);
```

当然，如果想更明确地表达当前正在使用命令模式，或者除了执行命令之外，将来有可能还 要提供撤销命令等操作。那我们最好还是把执行函数改为调用 execute 方法:

```javascript
var RefreshMenuBarCommand = function (receiver) {
  return {
    execute: function() {
      receiver.refresh();
    }
  }
};

var setCommand = function(button, command) {
  button.onclick = function() {
    command.execute();
  }
};

var refreshMenuBarCommand = RefreshMenuCommand(MenuBar);
setCommand(button1, refreshMenuBarCommand);
```

#### 命令队列

堆栈的实现方法。

#### 宏命令

宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。

```javascript
var closeDoorCommand = {
  execute: function() {
    console.log('关门')
  }
};

var openPcCommand = {
  execute: function () {
    console.log('开电脑')
  }
}

var openQQCommand = {
  execute: function () {
    console.log('登陆QQ')
  }
}

var MacroCommand = function() {
  return {
    commandsList: [],
    add: function () {
      this.commandsList.push(command);
    },
    excute: function() {
      for (var i = 0, command; command = this.commandsList[ i++ ]) {
        command.execute();
      }
    }
  }
};

var macroCommand = MacroCommand();
macroCommand.add( closeDoorCommand );
macroCommand.add( openPcCommand );
macroCommand.add( openQQCommand );

macroCommand.execute();
```

### 组合模式

组合模式最大的优点在于可以一致地对待组合对象和基本对象。客户不需要知道 当前处理的是宏命令还是普通命令，只要它是一个命令，并且有 execute 方法，这个命令就可以 被添加到树中。

组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和叶对象的区别，但它们在本质上有是区别的。

组合对象可以拥有子节点，叶对象下面就没有子节点， 所以我们也许会发生一些误操作， 比如试图往叶对象中添加子节点。解决方案通常是给叶对象也增加 add 方法，并且在调用这个方 法时，抛出一个异常来及时提醒客户。

#### 组合模式的例子-----扫描文件夹

```javascript
var Folder = function (name) {
  this.name = name;
  this.parent = null; //增加 this.parent 属性
  this.files = [];
}

Folder.prototype.add = function(file) {
  file.parent = this; //设置父对象
  this.files.push(file);
}

Folder.prototype.scan = function() {
  console.log( '开始扫描文件夹: ' + this.name );
  for (var i = 0, file, files = this.files; file = files[i++];) {
    file.scan();
  }
}

Folder.prototype.remove = function() {
  if (!this.parent) { // 根节点或者树外的游离节点。
    return;
  }
  for(var files = this.parent.files, l = files.length -1; l >= 0; l--) {
    var file = files[l];
    if (file == this) {
      files.splice(l, 1);
    }
  }
};
```

```javascript
var File = function(name) {
  this.name = name;
};

File.prototype.add = function() {
  throw new Error('文件下面不能添加文件')
}

File.prototype.scan = function() {
  console.log('开始扫描文件:' + this.name)
}

Folder.prototype.remove = function() {
  if (!this.parent) { // 根节点或者树外的游离节点。
    return;
  }
  for(var files = this.parent.files, l = files.length -1; l >= 0; l--) {
    var file = files[l];
    if (file == this) {
      files.splice(l, 1);
    }
  }
};
```

```javascript
var folder = new Folder( '学习资料' );
var folder1 = new Folder( 'JavaScript' );
var folder2 = new Folder ( 'jQuery' );

var file1 = new File('JavaScript 设计模式与开发实践' ); 
var file2 = new File('精通 jQuery' );
var file3 = new File('重构与模式' )

folder1.add( file1 ); 
folder2.add( file2 );

folder1.remove(); //移除文件夹

folder.add( folder1 ); 
folder.add( folder2 ); 
folder.add( file3 );
```

```javascript
var folder3 = new Folder( 'Nodejs' );
var file4 = new File( '深入浅出 Node.js' ); 
folder3.add( file4 );

var file5 = new File( 'JavaScript 语言精髓与编程实践' );

folder.add( folder3 ); 
folder.add( file5 );

folder.scan();
```

#### 何时使用组合模式

- 表示对象的部分整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分整 体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最 终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模 式中增加和删除树的节点非常方便，并且符合开放封闭原则。
- 客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别， 客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就 不用写一堆 if、else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情， 这是组合模式最重要的能力。

### 模板方法模式

这是一种基于继承的设计模式------模板方法。

#### 模板方法模式的定义和组成

模板方法模式是一种只需使用继承就可以实现的非常简单的模式。

模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺 序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。

#### 应用场景

在 Web 开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的 UI 组件， 这些组件的构建过程一般如下所示:

(1) 初始化一个 div 容器;
 (2) 通过 ajax 请求拉取相应的数据;
 (3) 把数据渲染到 div 容器里面，完成组件的构造; (4) 通知用户组件渲染完毕。

#### 钩子方法

钩子方法(hook)可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父 类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自 行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。

#### 好莱坞原则

在这一原则的指导下，我们允许底层组件将自己 挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对 待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。

#### JavaScript中的实现

```javascript
var Beverage = function(param) {
  var boilWater = function() {
    console.log('把水煮沸')
  }
  
  var brew = param.brew || function() {
    throw new Error('必须传递brew方法')
  }
  
  var pourInCup = param.pourInCup || function() {
    throw new Error('必须传递pourInCup方法')
  }
  
  var addCondiments = param.addCondiments || function() {
    throw new Error('必须传递addCondiments方法')
  }
  
  var F = function() {};
  
  F.prototype.init = function() {
    boilWater();
   	brew();
		pourInCup();
    addCondiments();
  }
  
  return F;
}

var Coffee = Beverage({ 
  brew: function(){
		console.log( '用沸水冲泡咖啡' ); 
  },
	pourInCup: function(){
		console.log( '把咖啡倒进杯子' );
  },
  addCondiments: function(){
		console.log( '加糖和牛奶' ); 
  }
});

var Tea = Beverage({ 
  brew: function(){
		console.log( '用沸水浸泡茶叶' ); 
  },
	pourInCup: function(){
		console.log( '把茶倒进杯子' );
 },
 addCondiments: function(){
		console.log( '加柠檬' ); 
 }
});

var coffee = new Coffee();
coffee.init();

var tea = new Tea();
tea.init();
```

#### 小结

模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语 言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把 这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这 部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改 动抽象父类以及其他子类，这也是符合开放封闭原则的。

### 享元模式

享元(flyweight)模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量 5 级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。

如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非 常有意义的事情。

享元模式要求将对象的属性划分为内部状态与外部 状态(状态在这里通常指属性)。享元模式的目标是尽量减少共享对象的数量，关于如何划分内 部状态和外部状态。

 内部状态存储于对象内部。
  内部状态可以被一些对象共享。
  内部状态独立于具体的场景，通常不会改变。
  外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。

剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整 的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系 统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间 的优化模式。剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整 的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系 统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。

#### 文件上传的例子

1.剥离外部状态

```javascript
var Upload = function(uploadType) {
  this.uploadType = uploadType;
}

Upload.prototype.delFile = function(id) {
  uploadManager.setExternalState(id, this);  // (1)
  
  if (this.fileSize < 3000) {
    return this.dom.parentNode.removeChild(this.dom);
  }
  
  if (window.confirm('确定要删除该文件吗？' + this.fileName)) {
    return this.dom.parentNode.removeChild(this.dom);
  }
};
```

2.工厂进行对象实例化

```javascript
var UploadFactory = (function() {
  var createdFlyWeightObjs = {};
  
  return {
    create:function(uploadType) {
      if (createdFlyWeightObjs[uploadType]) {
        return createdFlyWeightObjs[uploadType]
      }
      
      return createdFlyWightObjs[uploadType] = new Upload(uploadType);
    }
  }
})
```

3.管理器封装外部状态

```javascript
var uploadManager = (function() {
  var uploadDatabase = {};
  return {
    add: function (id, uploadType, fileName, fileSize) {
      var flyWeightObj = UploadFactory.create(uploadType);
      
      var dom = document.createElement( 'div' ); 
      dom.innerHTML =
				'<span>文件名称:'+ fileName +', 文件大小: '+ fileSize +'</span>' + '<button class="delFile">删除</button>';

      dom.querySelector( '.delFile' ).onclick = function(){ 
        flyWeightObj.delFile( id );
      }
      document.body.appendChild( dom );
      
      uploadDatabase[id] = {
        fileName: fileName,
        fileSize: fileSize,
        dom: dom,
      };
      
      return flyWeightObj;
    },
    setExternalState: function(id, flyWeightObj) {
      var uploadData = uploadDatabase[ id ];
			for ( var i in uploadData ){
				flyWeightObj[ i ] = uploadData[ i ]; 
      }
    }
  }
})();
```

#### 享元模式的适用性

享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时 便可以使用享元模式。

1. 对象的大多数状态都可以变为外部状态。
2. 一个程序中使用了大量的相似对象。
3. 由于使用了大量对象，造成很大的内存开销。
4. 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。

#### 对象池的实现

气泡窗的应用

##### 通用对象池的实现

```javascript
var objectPoolFactory = function(createObjFn) {
  var objectPool = [];
  
  return {
    create: function() {
      var obj = objectPool.length === 0 ?
          createObjFn.apply(this, arguments) : objectPool.shift();
      return obj;
    },
    recover: function (obj) {
      objectPool.push(obj);
    }
  }
};
```

### 职责链模式

职责链模式的定义是:使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间 5的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对 象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。

#### 例子：

orderType:表示订单类型(定金用户或者普通购买用户)，code 的值为 1 的时候是 500 元 定金用户，为 2 的时候是 200 元定金用户，为 3 的时候是普通购买用户。

pay:表示用户是否已经支付定金，值为 true 或者 false, 虽然用户已经下过 500 元定金的 订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。

stock:表示当前用于普通购买的手机库存数量，已经支付过 500 元或者 200 元定金的用 户不受此限制。

```javascript
var order500 = function(orderType, pay, stock) {
  if (orderType === 1  && pay === true) {
    console.log( '500元定金预购，得到100优惠券')
  } else {
    return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递
  }
}

var order200 = function( orderType, pay, stock ){ 
  if ( orderType === 2 && pay === true ){
    console.log( '200 元定金预购，得到 50 优惠券' ); 
  }else{
    return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 
  }
};

var orderNormal = function( orderType, pay, stock ){
  if ( stock > 0 ){
    console.log( '普通购买，无优惠券' ); 
  }else{
    console.log( '手机库存不足' ); 
  }
};

// Chain.prototype.setNextSuccessor 指定在链中的下一个节点
// Chain.prototype.passRequest 传递请求给某个节点
var Chain = function( fn ) {
  this.fn = fn;
  this.successor = null;
};

Chain.prototype.setNextSuccessor = function(successor) {
  return this.successor = successor;
}

Chain.prototype.passRequest = function() {
  var ret = this.fn.apply(this, arguments);
  
  if (ret === 'nextSuccessor') {
    return this.successor && this.successor.passRequest.apply( this.successor, arguments);
  }
  
  return ret;
}

var chainOrder500 = new Chain( order500 );
var chainOrder200 = new Chain( order200 );
var chainOrderNormal = new Chain( orderNormal );

chainOrder500.setNextSuccessor( chainOrder200 ); 
chainOrder200.setNextSuccessor( chainOrderNormal); // 最后把请求传递给第一个节点:

chainOrder500.passRequest( 1, true, 500 );  // 输出:500 元定金预购，得到 100 优惠券 
chainOrder500.passRequest( 2, true, 500 ); // 输出:200 元定金预购，得到 50 优惠券 
chainOrder500.passRequest( 3, true, 500 );  // 输出:普通购买，无优惠券
chainOrder500.passRequest( 1, false, 0 ); // 输出:手机库存不足
```

#### 异步的职责链

```javascript
Chain.prototype.next = function() {
  return this.successor && this.successor.passRequest.apply(this.successor, arguments);
};

var fn1 = new Chain(function() {
  console.log(1);
  return 'nextSuccessor';
})

var fn2 = new Chain(function() {
  console.log(2);
  var self = this;
  setTimeout(function() {
    self.next();
  }, 1000);
});

var fn3 = new Chain(function() {
  console.log(3)
});

fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);
fn1.passRequest();
```

#### 职责链模式的优缺点

用了职 责链模式之后，每种订单都有各自的处理函数而互不影响。

其次，使用了职责链模式之后，链中的节点对象可以灵活地拆分重组。增加或者删除一个节 点，或者改变节点在链中的位置都是轻而易举的事情。

职责链模式还有一个优点，那就是可以手动指定起始节点，请求并不是非得从链中的第一个 节点开始传递。

如果运用得当，职责链模式可以很好地帮助我们组织代码，但这种模式也并非没有弊端，首 先我们不能保证某个请求一定会被链中的节点处理。

另外，职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分 节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避 免过长的职责链带来的性能损耗。

#### 用AOP实现职责链

```javascript
Function.prototype.after = function( fn ){ 
  var self = this;
  return function(){
    var ret = self.apply( this, arguments );
    if ( ret === 'nextSuccessor' ){
      return fn.apply( this, arguments );
    }
    return ret; 
  }
};
var order = order500yuan.after( order200yuan ).after( orderNormal );

order( 1, true, 500 ); // 输出:500 元定金预购，得到 100 优惠券
order( 2, true, 500 );  // 输出:200 元定金预购，得到 50 优惠券
order( 1, false, 500 ); // 输出:普通购买，无优惠券
```

#### 用职责链模式获取文件上传对象

```javascript
var getActiveUploadObj = function() {
  try {
    return new ActiveXObject("TXFTNActiveX.FTNUpload"); // IE 上传控件
  } catch(e) {
    return 'nextSuccessor';
  }
}

var getFlashUploadObj = function() {
  if (supportFlash()) {
    var str = '<object type="application/x-shockwave-flash"></object>';
    return $( str ).appendTo( $('body') );
  }
  return 'nextSuccessor';
}

var getFormUploadObj = function() {
  return $( '<form><input name="file" type="file"/></form>' ).appendTo( $('body') );
}

var getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUploadObj);

console.log(getUploadObj());
```

#### 小结

在 JavaScript 开发中，职责链模式是最容易被忽视的模式之一。实际上只要运用得当，职责 链模式可以很好地帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。职 责链中的节点数量和顺序是可以自由变化的，我们可以在运行时决定链中包含哪些节点。

无论是作用域链、原型链，还是 DOM 节点中的事件冒泡，我们都能从中找到职责链模式的 影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的 效率。学会使用职责链模式，相信在以后的代码编写中，将会对你大有裨益。

### 中介者模式

中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。

#### 用中介者模式改造泡泡堂游戏

玩家

```javascript
function Player( name, teamColor ){
  this.name = name; // 角色名字 
  this.teamColor = teamColor; // 队伍颜色 
  this.state = 'alive'; // 玩家生存状态
};

Player.prototype.win = function(){ 
  console.log( this.name + ' won ' );
};

Player.prototype.lose = function(){
  console.log( this.name +' lost' );
};

/*******************玩家死亡*****************/
Player.prototype.die = function(){
  this.state = 'dead';
  playerDirector.reciveMessage( 'playerDead', this ); // 给中介者发送消息，玩家死亡
};

/*******************移除玩家*****************/
Player.prototype.remove = function(){ 
  playerDirector.reciveMessage( 'removePlayer', this ); // 给中介者发送消息，移除一个玩家
};

/*******************玩家换队*****************/
Player.prototype.changeTeam = function( color ){
  playerDirector.reciveMessage( 'changeTeam', this, color ); // 给中介者发送消息，玩家换队
};
```

工厂函数

```javascript
var playerFactory = function( name, teamColor ){
  var newPlayer = new Player( name, teamColor ); // 创造一个新的玩家对象
  playerDirector.reciveMessage( 'addPlayer', newPlayer ); // 给中介者发送消息，新增玩家
  return newPlayer; 
};
```

中介

```javascript
var playerDirector= ( 
  function(){
    var players = {}, // 保存所有玩家
        operations = {}; // 中介者可以执行的操作
    
    /****************新增一个玩家***************************/ 
    operations.addPlayer = function( player ){
      var teamColor = player.teamColor; // 玩家的队伍颜色
      players[ teamColor ] = players[ teamColor ] || []; // 如果该颜色的玩家还没有成立队伍，则新成立一个队伍 
      players[ teamColor ].push( player ); // 添加玩家进队伍
    };
    
    /****************移除一个玩家***************************/ 
    operations.removePlayer = function( player ){
      var teamColor = player.teamColor, // 玩家的队伍颜色
          teamPlayers = players[ teamColor ] || []; // 该队伍所有成员
      for ( var i = teamPlayers.length - 1; i >= 0; i-- ){ // 遍历删除
        if ( teamPlayers[ i ] === player ){ 
          teamPlayers.splice( i, 1 );
        } 
      }
    };
    
    /****************玩家换队***************************/
    operations.changeTeam = function( player, newTeamColor ){ // 玩家换队
      operations.removePlayer( player ); // 从原队伍中删除
      player.teamColor = newTeamColor;  // 改变队伍颜色
      operations.addPlayer( player ); // 增加到新队伍中
    }
    
    operations.playerDead = function( player ){ // 玩家死亡
      var teamColor = player.teamColor,
          teamPlayers = players[ teamColor ]; // 玩家所在队伍
      
      var all_dead = true;
      
      for ( var i = 0, player; player = teamPlayers[ i++ ]; ){ 
        if ( player.state !== 'dead' ){
          all_dead = false;
          break; 
        }
      }
      
      if ( all_dead === true ){  // 全部死亡
        for ( var i = 0, player; player = teamPlayers[ i++ ]; ){ 
          player.lose(); // 本队所有玩家 lose
        }
        for ( var color in players ){ 
          if ( color !== teamColor ){
            var teamPlayers = players[color]; // 其他队伍的玩家
            for (var i = 0, player; player = teamPlayers[i++];) {
              player.win(); // 其他队伍所有玩家 win
            }
          }
        }
      }
    };
    
    var reciveMessage = function() {
      var message = Array.prototype.shift.call(arguments); // arguments 的第一个参数为消息名称
      operations[message].apply(this, arguments);
    }
    
    return {
      reciveMessage: reciveMessage
    }
  })();
      
```

#### 小结

中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应 该尽可能少地了解另外的对象(类似不和陌生人说话)。如果对象之间的耦合性太高，一个对象 发生改变之后，难免会影响到其他的对象，跟“城门失火，殃及池鱼”的道理是一样的。而在中 介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。

因此，中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象 之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者 对象来实现和维护。

不过，中介者模式也存在一些缺点。其中，最大的缺点是系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。

### 装饰者模式

同样，在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责。那么我们就可以使用装饰者模式。装饰者模式可以动态地 给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。

在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活， 还会带来许多问题:一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之 改变;另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的， 在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。

装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式。

#### 用AOP装饰函数

```javascript
Function.prototype.before = function( beforefn ){
  var __self = this; // 保存原函数的引用
  return function(){ // 返回包含了原函数和新函数的"代理"函数
    beforefn.apply( this, arguments ); // 执行新函数，且保证 this 不被劫持，新函数接受的参数 // 也会被原封不动地传入原函数，新函数在原函数之前执行
    return __self.apply( this, arguments ); // 执行原函数并返回原函数的执行结果， 2 // 并且保证 this 不被劫持
  } 
}
Function.prototype.after = function( afterfn ){ 
  var __self = this;
  return function(){
    var ret = __self.apply( this, arguments ); 
    afterfn.apply( this, arguments );
    return ret;
  } 
};
```

可以应用在:

数据上报、统计函数的执行时间、动态改变函数参数以及插件式的表单验证

### 状态模式

状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。

#### 状态模式的定义

允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

#### 状态模式重构文件上传程序

```javascript
window.external.upload = function( state ){
	console.log( state ); // 可能为 sign、uploading、done、error
};
var plugin = (function(){
  var plugin = document.createElement( 'embed' ); 
  plugin.style.display = 'none';
  plugin.type = 'application/txftn-webkit';
  plugin.sign = function(){ 
    console.log( '开始文件扫描' );
  }
  plugin.pause = function(){ 
    console.log( '暂停文件上传' );
  }; 
  plugin.uploading = function(){ 
    console.log( '开始文件上传' );
  };
  plugin.del = function(){
    console.log( '删除文件上传' ); 
  }
  document.body.appendChild( plugin );
  plugin.done = function(){ 
    console.log( '文件上传完成' );
  }
  return plugin; 
})();
```

改造 Upload 构造函数，在构造函数中为每种状态子类都创建一个实例对象:

```javascript
var Upload = function( fileName ){
  this.plugin = plugin;
  this.fileName = fileName;
  this.button1 = null;
  this.button2 = null;
  this.signState = new SignState( this );  // 设置初始状态为 waiting
  this.uploadingState = new UploadingState( this );
  this.pauseState = new PauseState( this ); 
  this.doneState = new DoneState( this ); 
  this.errorState = new ErrorState( this ); 
  this.currState = this.signState; // 设置当前状态
};
```

```javascript
Upload.prototype.init = function(){
  var that = this;
  this.dom = document.createElement( 'div' ); 
  this.dom.innerHTML =
    '<span>文件名称:'+ this.fileName +'</span>\ <button data-action="button1">扫描中</button>\ <button data-action="button2">删除</button>';
  document.body.appendChild( this.dom );
  this.button1 = this.dom.querySelector( '[data-action="button1"]' ); 
  this.button2 = this.dom.querySelector( '[data-action="button2"]' );
  this.bindEvent(); 
};
```

```javascript
Upload.prototype.bindEvent = function(){ 
  var self = this; 
  this.button1.onclick = function(){
    self.currState.clickHandler1(); 
  }
  this.button2.onclick = function(){ 
    self.currState.clickHandler2();
  } 
};
```

```javascript
Upload.prototype.sign = function(){ 
  this.plugin.sign(); 
  this.currState = this.signState;
};

Upload.prototype.uploading = function(){ 
  this.button1.innerHTML = '正在上传，点击暂停'; 
  this.plugin.uploading();
  this.currState = this.uploadingState;
};

Upload.prototype.pause = function(){
  this.button1.innerHTML = '已暂停，点击继续上传'; 
  this.plugin.pause();
  this.currState = this.pauseState;
};

Upload.prototype.done = function(){ 
  this.button1.innerHTML = '上传完成'; 
  this.plugin.done();
  this.currState = this.doneState;
};

Upload.prototype.error = function(){ 
  this.button1.innerHTML = '上传失败'; 
  this.currState = this.errorState;
};

Upload.prototype.del = function(){ 
  this.plugin.del(); 
  this.dom.parentNode.removeChild( this.dom );
};
```

```javascript
var StateFactory = (function(){
  var State = function(){}; 
  
  State.prototype.clickHandler1 = function(){
    throw new Error( '子类必须重写父类的 clickHandler1 方法' );
  }
  
  State.prototype.clickHandler2 = function(){
    throw new Error( '子类必须重写父类的 clickHandler2 方法' );
  }

  return function( param ){
    var F = function( uploadObj ){ 
      this.uploadObj = uploadObj;
    };
    F.prototype = new State();
    for ( var i in param ){ 
      F.prototype[ i ] = param[ i ];
    }
    return F; 
  }
})();

var SignState = StateFactory({
  clickHandler1: function(){
    console.log( '扫描中，点击无效...' );
  },
  clickHandler2: function(){
    console.log( '文件正在上传中，不能删除' ); 
  }
});

var UploadingState = StateFactory({ 
  clickHandler1: function(){
    this.uploadObj.pause(); 
  },
  clickHandler2: function(){
    console.log( '文件正在上传中，不能删除' );
  } 
});

var PauseState = StateFactory({ 
  clickHandler1: function(){
    this.uploadObj.uploading(); 
  },
  clickHandler2: function(){ 
    this.uploadObj.del();
  } 
});

var DoneState = StateFactory({ 
  clickHandler1: function(){
    console.log( '文件已完成上传, 点击无效' ); 
  },
  clickHandler2: function(){ 
    this.uploadObj.del();
  } 
});

var ErrorState = StateFactory({ 
  clickHandler1: function(){
    console.log( '文件上传失败, 点击无效' ); 
  },
  clickHandler2: function(){ 
    this.uploadObj.del();
  } 
});

// 最后是测试时间:
var uploadObj = new Upload( 'JavaScript 设计模式与开发实践' ); 
uploadObj.init();
window.external.upload = function( state ){ 
  uploadObj[ state ]();
};
window.external.upload( 'sign' );
setTimeout(function(){ 
  window.external.upload( 'uploading' );
}, 1000 );
setTimeout(function(){ 
  window.external.upload( 'done' );
}, 5000 );
```

#### 状态模式的优缺点

优点：

1.状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。

2.避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过 5 多的条件分支。

3.用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。

4.Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。

缺点：

状态模式的缺点是会在系统中定义许多状态类。

可优化点：

1.有两种选择来管理 state 对象的创建和销毁。第一种是仅当 state 对象被需要时才创建并 随后销毁，另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。如果 state 对象比较庞大，可以用第一种方式来节省内存，这样可以避免创建一些不会用到的对象 10 并及时地回收它们。但如果状态的改变很频繁，最好一开始就把这些 state 对象都创建出 来，也没有必要销毁它们，因为可能很快将再次用到它们。

2.享元模式

#### Javascript中的应用

```javascript
var Light = function(){
  this.currState = FSM.off; // 设置当前状态 this.button = null;
};

Light.prototype.init = function(){
  var button = document.createElement( 'button' ),
      self = this;
  button.innerHTML = '已关灯';
  this.button = document.body.appendChild( button );
  this.button.onclick = function(){ 
    self.currState.buttonWasPressed.call( self );
  } 
};

var FSM = { 
  off: {
    buttonWasPressed: function(){
      console.log( '关灯' ); 
      this.button.innerHTML = '下一次按我是开灯'; 
      this.currState = FSM.on;
    } 
  },
  on: {
    buttonWasPressed: function(){
      console.log( '开灯' ); 
      this.button.innerHTML = '下一次按我是关灯'; 
      this.currState = FSM.off;
    }
  }
}

var light = new Light(); 
light.init();
```

另外一种实现方法

```javascript
var delegate = function( client, delegation ){ 
  return {
    buttonWasPressed: function(){ // 将客户的操作委托给 delegation 对象 
      return delegation.buttonWasPressed.apply( client, arguments );
    } 
  }
};
var FSM = {
  off: {
    buttonWasPressed: function(){
      console.log( '关灯' ); 
      this.button.innerHTML = '下一次按我是开灯'; 
      this.currState = this.onState;
    }
  },
  on: {
    buttonWasPressed: function(){
      console.log( '开灯' );
      this.button.innerHTML = '下一次按我是关灯'; 
      this.currState = this.offState;
    } 
  }
};

var Light = function(){
  this.offState = delegate( this, FSM.off );
  this.onState = delegate( this, FSM.on );
  this.currState = this.offState; // 设置初始状态为关闭状态 
  this.button = null;
};

Light.prototype.init = function(){
  var button = document.createElement( 'button' ),
      self = this;
  button.innerHTML = '已关灯';
  this.button = document.body.appendChild( button ); 
  this.button.onclick = function(){
    self.currState.buttonWasPressed();
  }
};
var light = new Light();
light.init();
```

### 适配器模式

适配器的别名是包装器(wrapper)，这是一个相对简单的模式。在程序开发中有许多这样的 场景:当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿 到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建 一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。

