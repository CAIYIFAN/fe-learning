# 设计模式

## 观察者模式

任务订阅的大致功能是这样的: 宗门推出五星任务订阅功能，弟子通过购买获得订阅权限，当宗门发布五星任务后，会通知拥有订阅权限的弟子。

那么任务订阅功能中有两类主体:

- 宗门任务大殿
  - 维护拥有订阅权限的弟子列表
  - 提供弟子购买订阅权限的功能
  - 发布对应任务后通知有订阅权限的弟子
- 接受任务通知的弟子们

上面宗门任务大殿与弟子间的关系其实就构成了一个观察者模式。

**那什么是观察者模式那？** 当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。

在观察者模式中，只有两种主体：目标对象 (`Object`) 和 观察者 (`Observer`)。宗门任务大殿就是目标对象，弟子们就是观察者。

- 目标对象 

  ```
  Subject
  ```

  :

  - 维护观察者列表 `observerList` ———— 维护拥有订阅权限的弟子列表
  - 定义添加观察者的方法 ———— 提供弟子购买订阅权限的功能
  - 当自身发生变化后，通过调用自己的 `notify` 方法依次通知每个观察者执行 `update` 方法 ———— 发布对应任务后通知有订阅权限的弟子

- 观察者 `Observer` 需要实现 `update` 方法，供目标对象调用。`update`方法中可以执行自定义的业务逻辑 ———— 弟子们需要定义接收任务通知后的方法，例如去抢任务或任务不适合，继续等待下一个任务

我们把上面的文字形象化一下:

![Observer.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f96a826bb7945dd96f9696f41b45534~tplv-k3u1fbpfcp-watermark.awebp?)

```js
class Observer {
    constructor(name) {
        this.name = name;
    }
    update({taskType, taskInfo}) {
        // 假设任务分为日常route和战斗war
        if (taskType === "route") {
            console.log(`${this.name}不需要日常任务`);
            return;
        }
        this.goToTaskHome(taskInfo);
        
    }
    goToTaskHome(info) {
        console.log(`${this.name}去任务大殿抢${info}任务`);
    }
}

class Subject {
    constructor() {
        this.observerList = []
    }
    addObserver(observer) {
        this.observerList.push(observer);
    }
    notify(task) {
        console.log("发布五星任务");
        this.observerList.forEach(observer => observer.update(task))
    }
}

const subject = new Subject();
const stu1 = new Observer("弟子1");
const stu2 = new Observer("弟子2");

// stu1 stu2 购买五星任务通知权限
subject.addObserver(stu1);
subject.addObserver(stu2);

// 任务殿发布五星战斗任务
const warTask = {
    taskType: 'war',
    taskInfo: "猎杀时刻"
}

// 任务大殿通知购买权限弟子
subject.notify(warTask);

// 任务殿发布五星日常任务
const routeTask = {
    taskType: 'route',
    taskInfo: "种树浇水"
}

subject.notify(routeTask);

复制代码
```

输出结果:

```js
// 战斗任务
发布五星任务
弟子1去任务大殿抢猎杀时刻任务
弟子2去任务大殿抢猎杀时刻任务

// 日常任务
发布五星任务
弟子1不需要日常任务
弟子2不需要日常任务
复制代码
```

通过上面代码我们可以看到，当宗门发布任务后，订阅的弟子(观察者们)都会收到任务最新通知。

看到这里，不知道你可以理解观察者模式了？

**小包再给举个栗子**: 比如你要应聘阿里巴巴的前端工程师，结果阿里巴巴 HR 告诉你没坑位了，留下你的电话，等有坑位联系你。于是，你美滋滋的留下了联系方式。殊不知，HR 已经留下了好多联系方式。好在 2022 年 2 月 30 号那天，阿里巴巴有了前端工程师的坑位，HR 挨着给留下的联系方式联系了一通。

案例中阿里巴巴就是目标对象 `Subject` ，联系方式列表就是用来维护观察者的 `observerList` ，根据前端职位的有无来调用 `notify` 方法。

## 发布订阅模式

**那什么是发布订阅模式呐？** 基于一个事件（主题）通道，希望接收通知的对象 `Subscriber` 通过自定义事件订阅主题，被激活事件的对象 `Publisher` 通过发布主题事件的方式通知各个订阅该主题的 `Subscriber` 对象。

因此发布订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者 `Publisher` ，事件调度中心 `Event Channel` ，订阅者 `Subscriber` 。

上面的文字有些难以理解，我们继续以弟子领取任务为栗子，宗门感觉把任务订阅放在任务大殿中有些繁琐，于是决定在任务大殿和弟子中间添加**中介**。弟子在中介中订阅其需要的任务类型，当任务大殿发布任务后，中介会将发布任务给对应的订阅者。

- 宗门任务大殿: 任务发布者 —— `Publisher`

- 中介功能 —— 

  ```
  Event Channel
  ```

  - 维护任务类型，以及每种任务下的订阅情况
  - 给订阅者提供订阅功能 —— `subscribe` 功能
  - 当宗门发布任务后，中介会给所有的订阅者发布任务 —— `publish` 功能

- 弟子: 任务接受者 —— `Subscriber`

![publish-subscribe.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fc5d255760a4192a939785e427fabec~tplv-k3u1fbpfcp-watermark.awebp?)

**小包再给大家举个例子**: 以目前的**热播剧开端**为例，临近过年，摸鱼的心思越来越重，每天就迫不及待的等开端更新，想在开端更新的第一刻就开始看剧，那你会怎么做那？总不能时时刻刻刷新页面吧。平台提供了消息订阅功能，如果你选择订阅，平台更新开端后，会第一时间发消息通知你，订阅后，你就可以愉快的追剧了。

上面案例中，开端就是发布者 `Publisher`，追剧人就是订阅者 `Subscribe`，平台则承担了事件通道 `Event Channel` 功能。

```js
class PubSub {
    constructor() {
        // 事件中心
        // 存储格式: warTask: [], routeTask: []
        // 每种事件(任务)下存放其订阅者的回调函数
        this.events = {}
    }
    // 订阅方法
    subscribe(type, cb) {
        if (!this.events[type]) {
            this.events[type] = [];
        }
        this.events[type].push(cb);
    }
    // 发布方法
    publish(type, ...args) {
        if (this.events[type]) {
            this.events[type].forEach(cb => cb(...args))
        }
    }
    // 取消订阅方法
    unsubscribe(type, cb) {
        if (this.events[type]) {
            const cbIndex = this.events[type].findIndex(e=> e === cb)
            if (cbIndex != -1) {
                this.events[type].splice(cbIndex, 1);
            }
        }
        if (this.events[type].length === 0) {
            delete this.events[type];
        }
    }
    unsubscribeAll(type) {
        if (this.events[type]) {
            delete this.events[type];
        }
    }
}

// 创建一个中介公司
let pubsub = new PubSub();

// 弟子一订阅战斗任务
pubsub.subscribe('warTask', function (taskInfo){
    console.log("宗门殿发布战斗任务，任务信息:" + taskInfo);
})
// 弟子一订阅战斗任务
pubsub.subscribe('routeTask', function (taskInfo) {
    console.log("宗门殿发布日常任务，任务信息:" + taskInfo);
});
// 弟子三订阅全类型任务
pubsub.subscribe('allTask', function (taskInfo) {
    console.log("宗门殿发布五星任务，任务信息:" + taskInfo);
});

// 发布战斗任务
pubsub.publish('warTask', "猎杀时刻");
pubsub.publish('allTask', "猎杀时刻");

// 发布日常任务
pubsub.publish('routeTask', "种树浇水");
pubsub.publish('allTask', "种树浇水");
复制代码
```

输出结果:

```js
// 战斗任务
宗门殿发布战斗任务，任务信息:猎杀时刻
宗门殿发布五星任务，任务信息:猎杀时刻
// 日常任务
宗门殿发布日常任务，任务信息:种树浇水
宗门殿发布五星任务，任务信息:种树浇水
复制代码
```

通过输出结果，我们可以发现发布者和订阅者不知道对方的存在。需要第三方中介，将订阅者和发布者串联起来，利用中介过滤和分配所有输入的消息。也就是说，**发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在**。

## 观察者模式和发布订阅区别

上文中提到了观察者模式和发布——订阅模式，我们来总结一下两者差异:

![observer-publish_subscribe.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52a175a22ade4793a0297b18c5fb293d~tplv-k3u1fbpfcp-watermark.awebp?)

| 设计模式 | 观察者模式                                    | 发布订阅模式                                            |
| -------- | --------------------------------------------- | ------------------------------------------------------- |
| 主体     | Object观察者、Subject目标对象                 | Publisher发布者、Event Channel事件中心、Subscribe订阅者 |
| 主体关系 | Subject中通过observerList记录ObServer         | Publisher和Subscribe不想不知道对方，通过中介联系        |
| 优点     | 角色明确，Subject和Object要遵循约定的成员方法 | 松散耦合，灵活度高，通常应用在异步编程中                |
| 缺点     | 紧耦合                                        | 当事件类型变多时，会增加维护成本                        |
| 使用案例 | 双向数据绑定                                  | 事件总线EventBus                                        |

## IOC和AOP

### 什么是 IoC

IoC （Inversion of control ）控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。

例如：现有类 A 依赖于类 B

- **传统的开发方式** ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来
- **使用 IoC 思想的开发方式** ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。

从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）

#### 为什么叫控制反转

**控制** ：指的是对象创建（实例化、管理）的权力

**反转** ：控制权交给外部环境（Spring 框架、IoC 容器）

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a71315d1da13~tplv-t2oaga2asx-watermark.awebp)

### IoC 解决了什么问题

IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？

1. 对象之间的耦合度或者说依赖程度降低；
2. 资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。

例如：现有一个针对 User 的操作，利用 Service 和 Dao 两层结构进行开发

在没有使用 IoC 思想的情况下，Service 层想要使用 Dao 层的具体实现的话，需要通过 new 关键字在`UserServiceImpl` 中手动 new 出 `IUserDao` 的具体实现类 `UserDaoImpl`（不能直接 new 接口类）。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a71316001230~tplv-t2oaga2asx-watermark.awebp)

很完美，这种方式也是可以实现的，但是我们想象一下如下场景：

开发过程中突然接到一个新的需求，针对对`IUserDao` 接口开发出另一个具体实现类。因为 Server 层依赖了`IUserDao`的具体实现，所以我们需要修改`UserServiceImpl`中 new 的对象。如果只有一个类引用了`IUserDao`的具体实现，可能觉得还好，修改起来也不是很费力气，但是如果有许许多多的地方都引用了`IUserDao`的具体实现的话，一旦需要更换`IUserDao` 的实现方式，那修改起来将会非常的头疼。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b2d58ea769~tplv-t2oaga2asx-watermark.awebp)img

使用 IoC 的思想，我们将对象的控制权（创建、管理）交有 IoC 容器去管理，我们在使用的时候直接向 IoC 容器 “要” 就可以了

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b2d57b064b~tplv-t2oaga2asx-watermark.awebp)img

### IoC 和 DI 别再傻傻分不清楚

IoC（Inverse of Control:控制反转）是一种**设计思想** 或者说是某种模式。这个设计思想就是 **将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。** IoC 在其他语言中也有应用，并非 Spring 特有。**IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。**

IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。

并且，老马（Martin Fowler）在一篇文章中提到将 IoC 改名为 DI，原文如下，原文地址：https://martinfowler.com/articles/injection.html 。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b2d58818e7~tplv-t2oaga2asx-watermark.awebp)img

老马的大概意思是 IoC 太普遍并且不表意，很多人会因此而迷惑，所以，使用 DI 来精确指名这个模式比较好。

### 什么是 AOP

AOP：Aspect oriented programming 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续。

下面我们先看一个 OOP 的例子。

例如：现有三个类，`Horse`、`Pig`、`Dog`，这三个类中都有 eat 和 run 两个方法。

通过 OOP 思想中的继承，我们可以提取出一个 Animal 的父类，然后将 eat 和 run 方法放入父类中，`Horse`、`Pig`、`Dog`通过继承`Animal`类即可自动获得 `eat()` 和 `run()` 方法。这样将会少些很多重复的代码。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b2d5a302a7~tplv-t2oaga2asx-watermark.awebp)img

OOP 编程思想可以解决大部分的代码重复问题。但是有一些问题是处理不了的。比如在父类 Animal 中的多个方法的相同位置出现了重复的代码，OOP 就解决不了。

```
/**
 * 动物父类
 */
public class Animal {

    /** 身高 */
    private String height;

    /** 体重 */
    private double weight;

    public void eat() {
        // 性能监控代码
        long start = System.currentTimeMillis();

        // 业务逻辑代码
        System.out.println("I can eat...");

        // 性能监控代码
        System.out.println("执行时长：" + (System.currentTimeMillis() - start)/1000f + "s");
    }

    public void run() {
        // 性能监控代码
        long start = System.currentTimeMillis();

        // 业务逻辑代码
        System.out.println("I can run...");

        // 性能监控代码
        System.out.println("执行时长：" + (System.currentTimeMillis() - start)/1000f + "s");
    }
}
复制代码
```

这部分重复的代码，一般统称为 **横切逻辑代码**。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b2d5a2c5ab~tplv-t2oaga2asx-watermark.awebp)img

横切逻辑代码存在的问题：

- 代码重复问题
- 横切逻辑代码和业务代码混杂在一起，代码臃肿，不变维护

**AOP 就是用来解决这些问题的**

AOP 另辟蹊径，提出横向抽取机制，将横切逻辑代码和业务逻辑代码分离

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/28/1725a6b2d5fad550~tplv-t2oaga2asx-watermark.awebp)img

代码拆分比较容易，难的是如何在不改变原有业务逻辑的情况下，悄无声息的将横向逻辑代码应用到原有的业务逻辑中，达到和原来一样的效果。

### AOP 解决了什么问题

通过上面的分析可以发现，AOP 主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复。

### AOP 为什么叫面向切面编程

**切** ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑

**面** ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念

## 单例

### 单例模式的概念

> - 一个实例只生产一次
> - 保证一个类仅有一个实例，并提供一个访问它的全局访问点

### 方式1

利用instanceof判断是否使用new关键字调用函数进行对象的实例化

```js
function User() {
    if (!(this instanceof User)) {
        return
    }
    if (!User._instance) {
        this.name = '无名'
        User._instance = this
    }
    return User._instance
}

const u1 = new User()
const u2 = new User()

console.log(u1===u2);// true
```

### 方式2

在函数上直接添加方法属性调用生成实例

```js
function User(){
    this.name = '无名'
}
User.getInstance = function(){
    if(!User._instance){
        User._instance = new User()
    }
    return User._instance
}

const u1 = User.getInstance()
const u2 = User.getInstance()

console.log(u1===u2);
```

### 方式3

使用闭包，改进方式2

```js
function User() {
    this.name = '无名'
}
User.getInstance = (function () {
    var instance
    return function () {
        if (!instance) {
            instance = new User()
        }
        return instance
    }
})()

const u1 = User.getInstance()
const u2 = User.getInstance()

console.log(u1 === u2);
```

### 方式4

使用包装对象结合闭包的形式实现

```js
const User = (function () {
    function _user() {
        this.name = 'xm'
    }
    return function () {
        if (!_user.instance) {
            _user.instance = new _user()
        }
        return _user.instance
    }
})()

const u1 = new User()
const u2 = new User()

console.log(u1 === u2); // true
```

当然这里可以将闭包部分的代码单独封装为一个函数

**在频繁使用到单例的情况下，推荐使用类似此方法的方案，当然内部实现可以采用上述任意一种**

```js
function SingleWrapper(cons) {
    // 排除非函数与箭头函数
    if (!(cons instanceof Function) || !cons.prototype) {
        throw new Error('不是合法的构造函数')
    }
    var instance
    return function () {
        if (!instance) {
            instance = new cons()
        }
        return instance
    }
}

function User(){
    this.name = 'xm'
}
const SingleUser = SingleWrapper(User)
const u1 = new SingleUser()
const u2 = new SingleUser()
console.log(u1 === u2);
```

### 方式5

在构造函数中利用`new.target`判断是否使用new关键字

```js
class User{
    constructor(){
        if(new.target !== User){
            return
        }
        if(!User._instance){
            this.name = 'xm'
            User._instance = this
        }
        return User._instance
    }
}

const u1 = new User()
const u2 = new User()
console.log(u1 === u2);
```

### 方式6

使用`static`静态方法

```js
class User {
    constructor() {
        this.name = 'xm'
    }
    static getInstance() {
        if (!User._instance) {
            User._instance = new User()
        }
        return User._instance
    }
}


const u1 = User.getInstance()
const u2 = User.getInstance()

console.log(u1 === u2);
```

## 从继承,多态,封装三方面讲一下js是怎么实现的

### 封装

面向对象有三大特性，封装、继承和多态。对于ES5来说，没有`class`的概念，并且由于js的函数级作用域（在函数内部的变量在函数外访问不到），所以我们就可以模拟 `class`的概念，在es5中，类其实就是保存了一个函数的变量，这个函数有自己的属性和方法。将属性和方法组成一个类的过程就是封装。

> 封装：把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。

#### 通过构造函数添加

javascript提供了一个构造函数（Constructor）模式，用来在创建对象时初始化对象。
构造函数其实就是普通的函数，只不过有以下的特点

- 首字母大写（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写）
- 内部使用`this`
- 使用 `new`生成实例

通过构造函数添加属性和方法实际上也就是通过this添加的属性和方法。因为this总是指向当前对象的，所以通过this添加的属性和方法只在当前对象上添加，是该对象自身拥有的。所以我们实例化一个新对象的时候，this指向的属性和方法都会得到相应的创建，也就是会在内存中复制一份，这样就造成了内存的浪费。

```
function Cat(name,color){
        this.name = name;
        this.color = color;
        this.eat = function () {
            alert('吃老鼠')
        }
    }复制代码
```

生成实例：

```
var cat1 = new Cat('tom','red')复制代码
```

**通过this定义的属性和方法，我们实例化对象的时候都会重新复制一份**

#### 通过原型prototype

在类上通过 `this`的方式添加属性和对象会导致内存浪费的问题，我们就考虑，有什么方法可以让实例化的类所使用的方法直接使用指针指向同一个方法。于是，就想到了原型的方式

> Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。
> 也就是说，对于那些不变的属性和方法，我们可以直接将其添加在类的`prototype` 对象上。

```
　function Cat(name,color){
　　　　this.name = name;
　　　　this.color = color;
　　}
　　Cat.prototype.type = "猫科动物";
　　Cat.prototype.eat = function(){alert("吃老鼠")};复制代码
```

然后生成实例

```
var cat1 = new Cat("大毛","黄色");
　　var cat2 = new Cat("二毛","黑色");
　　alert(cat1.type); // 猫科动物
　　cat1.eat(); // 吃老鼠复制代码
```

这时所有实例的`type`属性和`eat()`方法，其实都是同一个内存地址，指向`prototype`对象，因此就提高了运行效率。

#### 在类的外部通过.语法添加

我们还可以在类的外部通过`.` 语法进行添加，因为在实例化对象的时候，并不会执行到在类外部通过`.` 语法添加的属性，所以实例化之后的对象是不能访问到`.` 语法所添加的对象和属性的，只能通过该类访问。

#### 三者的区别

通过构造函数、原型和`.` 语法三者都可以在类上添加属性和方法。但是三者是有一定的区别的。
**构造函数**：通过this添加的属性和方法总是指向当前对象的，所以在实例化的时候，通过this添加的属性和方法都会在内存中复制一份，这样就会造成内存的浪费。但是这样创建的好处是即使改变了某一个对象的属性或方法，不会影响其他的对象（因为每一个对象都是复制的一份）。
**原型**：通过原型继承的方法并不是自身的，我们要在原型链上一层一层的查找，这样创建的好处是只在内存中创建一次，实例化的对象都会指向这个`prototype` 对象，但是这样做也有弊端，因为实例化的对象的原型都是指向同一内存地址，改动其中的一个对象的属性可能会影响到其他的对象
**`.` 语法**：在类的外部通过`.` 语法创建的属性和方法只会创建一次，但是这样创建的实例化的对象是访问不到的，只能通过类的自身访问

### javascript也有private public protected

对于java程序员来说private public protected这三个关键字应该是很熟悉的哈，但是在js中，并没有类似于private public protected这样的关键字，但是我们又希望我们定义的属性和方法有一定的访问限制，于是我们就可以模拟private public protected这些访问权限。
不熟悉java的小伙伴可能不太清楚private public protected概念（其他语言我也不清楚有没有哈，但是应该都是类似的~），先来科普一下小知识点~

- public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用
- private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。
- protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。

#### js中的private

因为javascript函数级作用域的特性（在函数中定义的属性和方法外界访问不到），所以我们在函数内部直接定义的属性和方法都是私有的。

#### js中的public

通过new关键词实例化时，this定义的属性和变量都会被复制一遍，所以通过this定义的属性和方法就是公有的。
通过prototype创建的属性在类的实例化之后类的实例化对象也是可以访问到的，所以也是公有的。

#### js中的protected

在函数的内部，我们可以通过this定义的方法访问到一些类的私有属性和方法，在实例化的时候就可以初始化对象的一些属性了。

#### new的实质

虽然很多人都已经了解了new的实质，那么我还是要再说一下new 的实质
 `var o = new Object()`

1. 新建一个对象o
2. `o. __proto__ = Object.prototype` 将新创建的对象的`__proto__`属性指向构造函数的`prototype`
3. 将this指向新创建的对象
4. 返回新对象，但是这里需要看构造函数有没有返回值，如果构造函数的返回值为基本数据类型`string,boolean,number,null,undefined`,那么就返回新对象，如果构造函数的返回值为对象类型，那么就返回这个对象类型

#### 栗子~

```
var Book = function (id, name, price) {
        //private(在函数内部定义，函数外部访问不到，实例化之后实例化的对象访问不到)
        var num = 1;
        var id = id;
        function checkId() {
            console.log('private')
        }
        //protected(可以访问到函数内部的私有属性和私有方法，在实例化之后就可以对实例化的类进行初始化拿到函数的私有属性)
        this.getName = function () {
            console.log(id)
        }
        this.getPrice = function () {
            console.log(price)
        }

        //public(实例化的之后，实例化的对象就可以访问到了~)
        this.name = name;
        this.copy = function () {
            console.log('this is public')
        }

    }

    //在Book的原型上添加的方法实例化之后可以被实例化对象继承
    Book.prototype.proFunction = function () {
        console.log('this is proFunction')
    }

    //在函数外部通过.语法创建的属性和方法，只能通过该类访问，实例化对象访问不到
    Book.setTime = function () {
        console.log('this is new time')
    }
    var book1 = new Book('111','悲惨世界','$99')
    book1.getName();        // 111 getName是protected，可以访问到类的私有属性，所以实例化之后也可以访问到函数的私有属性
    book1.checkId();        //报错book1.checkId is not a function
    console.log(book1.id)   // undefined id是在函数内部通过定义的，是私有属性，所以实例化对象访问不到
    console.log(book1.name) //name 是通过this创建的，所以在实例化的时候会在book1中复制一遍name属性，所以可以访问到
    book1.copy()            //this is public
    book1.proFunction();    //this is proFunction
    Book.setTime();         //this is new time
    book1.setTime();        //报错book1.setTime is not a function复制代码
```

### 继承

> 继承：子类可以使用父类的所有功能，并且对这些功能进行扩展。继承的过程，就是从一般到特殊的过程。

其实继承都是基于以上封装方法的三个特性来实现的。

#### 类式继承

所谓的类式继承就是使用的原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象。

```
//声明父类
    var SuperClass = function () {
        var id = 1;
        this.name = ['javascript'];
        this.superValue = function () {
            console.log('superValue is true');
            console.log(id)
        }
    };

    //为父类添加共有方法
    SuperClass.prototype.getSuperValue = function () {
        return this.superValue();
    };

    //声明子类
    var SubClass = function () {
        this.subValue = function () {
            console.log('this is subValue ')
        }
    };

    //继承父类
    SubClass.prototype = new SuperClass() ;

    //为子类添加共有方法
    SubClass.prototype.getSubValue= function () {
        return this.subValue()
    };

    var sub = new SubClass();
    var sub2 =  new  SubClass();

    sub.getSuperValue();   //superValue is true
    sub.getSubValue();     //this is subValue

    console.log(sub.id);    //undefined
    console.log(sub.name);  //javascript

    sub.name.push('java');  //["javascript"]
    console.log(sub2.name)  //["javascript", "java"]复制代码
```

其中最核心的一句代码是`SubClass.prototype = new SuperClass() ;`
类的原型对象`prototype`对象的作用就是为类的原型添加共有方法的，但是类不能直接访问这些方法，只有将类实例化之后，新创建的对象复制了父类构造函数中的属性和方法，并将原型`__proto__` 指向了父类的原型对象。这样子类就可以访问父类的`public` 和`protected` 的属性和方法，同时，父类中的`private` 的属性和方法不会被子类继承。

敲黑板，如上述代码的最后一段，使用类继承的方法，如果父类的构造函数中有引用类型，就会在子类中被所有实例共用，因此一个子类的实例如果更改了这个引用类型，就会影响到其他子类的实例。
**提一个小问题~为什么一个子类的实例如果更改了这个引用类型，就会影响到其他子类的实例呢，在javascript中，什么是引用类型呢，引用类型和其他的类型又有什么区别呢？**

#### 构造函数继承

正式因为有了上述的缺点，才有了构造函数继承，构造函数继承的核心思想就是`SuperClass.call(this,id)`,直接改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题

```
//构造函数继承
    //声明父类
    function SuperClass(id) {
        var name = 'javascript'
        this.books=['javascript','html','css'];
        this.id = id
    }

    //声明父类原型方法
    SuperClass.prototype.showBooks = function () {
        console.log(this.books)
    }

    //声明子类
    function SubClass(id) {
        SuperClass.call(this,id)
    }

    //创建第一个子类实例
    var subclass1 = new SubClass(10);
    var subclass2 = new SubClass(11);

    console.log(subclass1.books);
    console.log(subclass2.id);
    console.log(subclass1.name);   //undefined
    subclass2.showBooks();复制代码
```

#### 组合式继承

我们先来总结一下类继承和构造函数继承的优缺点

|          | 类继承                                     | 构造函数继承             |
| -------- | ------------------------------------------ | ------------------------ |
| 核心思想 | 子类的原型是父类实例化的对象               | SuperClass.call(this,id) |
| 优点     | 子类实例化对象的属性和方法都指向父类的原型 | 每个实例化的子类互不影响 |
| 缺点     | 子类之间可能会互相影响                     | 内存浪费                 |

所以组合式继承就是汲取两者的优点，即避免了内存浪费，又使得每个实例化的子类互不影响。

```
//组合式继承
    //声明父类
    var SuperClass = function (name) {
        this.name = name;
        this.books=['javascript','html','css']
    };
    //声明父类原型上的方法
    SuperClass.prototype.showBooks = function () {
        console.log(this.books)
    };

    //声明子类
    var SubClass = function (name) {
        SuperClass.call(this, name)

    };

    //子类继承父类（链式继承）
    SubClass.prototype = new SuperClass();

    //实例化子类
    var subclass1 = new SubClass('java');
    var subclass2 = new SubClass('php');
    subclass2.showBooks();
    subclass1.books.push('ios');    //["javascript", "html", "css"]
    console.log(subclass1.books);  //["javascript", "html", "css", "ios"]
    console.log(subclass2.books);   //["javascript", "html", "css"]复制代码
```

#### 寄生组合继承

那么问题又来了~组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了寄生组合继承。
刚刚问题的关键是父类的构造函数在类继承和构造函数继承的组合形式中被创建了两遍，但是在类继承中我们并不需要创建父类的构造函数，我们只是要子类继承父类的原型即可。所以说我们先给父类的原型创建一个副本，然后修改子类`constructor`属性，最后在设置子类的原型就可以了~

```
//原型式继承
    //原型式继承其实就是类式继承的封装,实现的功能是返回一个实例，改实例的原型继承了传入的o对象
    function inheritObject(o) {
        //声明一个过渡函数对象
        function F() {}
        //过渡对象的原型继承父对象
        F.prototype = o;
        //返回一个过渡对象的实例，该实例的原型继承了父对象
        return new F();
    }
    //寄生式继承
    //寄生式继承就是对原型继承的第二次封装，使得子类的原型等于父类的原型。并且在第二次封装的过程中对继承的对象进行了扩展
    function inheritPrototype(subClass, superClass){
        //复制一份父类的原型保存在变量中，使得p的原型等于父类的原型
        var p = inheritObject(superClass.prototype);
        //修正因为重写子类原型导致子类constructor属性被修改
        p.constructor = subClass;
        //设置子类的原型
        subClass.prototype = p;
    }
    //定义父类
    var SuperClass = function (name) {
        this.name = name;
        this.books = ['javascript','html','css']
    };
    //定义父类原型方法
    SuperClass.prototype.getBooks = function () {
        console.log(this.books)
    };

    //定义子类
    var SubClass = function (name) {
        SuperClass.call(this,name)
    }

    inheritPrototype(SubClass,SuperClass);

    var subclass1 = new SubClass('php')
```

## JavaScript 装饰器

JavaScript的装饰器可以看作是一个函数，这个函数将目标函数的target、name以及descriptor作为它的参数。

target是指目标构造函数。例如，如果装饰器在class的构造函数中，target指向class的构造函数。如果装饰器在class的方法中，target指向这个方法。

name就是指向方法的method。class构造函数的装饰器没有name。

descriptor描述的是数据和访问器。如果你曾经使用过Object.defineProperty()，说明你使用过描述符（descriptor）。数据和访问器的描述符都共享所需的keys，configurable （可修改的）enumerable（例如 可以被for...in遍历到）。数据描述符有其他的keys，value 和 writable（重新赋值）。访问器有其他的keys：get（getter）和set（setter）。

一个使用数据descriptor来修改属性的例子：

```text
Object.defineProperty(obj, 'key', {
  enumerable: false,
  configurable: false,
  writable: false,
  value: 'static'
});
```

## 实例

下面是JavaScript中装饰器的一些例子：

### 只读的装饰器

在这个例子中，装饰器使得方法只读，这意味着我们不能修改这个方法。我们要做的就是设置writable描述符属性为false。

```text
function readonly(target, name, descriptor) {
  descriptor.writable = false;
  return descriptor;
}
```

只读装饰器的使用：

```text
class Robot {
  @readonly
  destroyHumans() {
    return `Destroying humans.`;
  }
}

const robot = new Robot();
console.log(robot.destroyHumans());
// "Destroying humans."

robot.destroyHumans = () => { return false; };
// TypeError: Cannot assign to read only property 'destroyHumans' of [object Object]
```

现在没有办法组织robots毁灭人类了。

### 日志装饰器

装饰器一种很方便的用法就是快速为方法添加记录日志的行为。下面这个例子中，我们实现了一个日志装饰器，函数被调用时会记录函数名。这个装饰器也可以自定义日志消息。请注意，如果我们要为装饰器提供参数，我们需要返回一个函数。

```text
function log(target, name, descriptor) {
  let message = `LOG: Calling \`${name}\` function.`;

  if (typeof target === 'string') {
    message = target;

    return (target, name, descriptor) => {
      console.log(`LOG: ${message}`, name);
      return descriptor;
    };
  } else {
    console.log(message);
    return descriptor;
  }
}
```

日志装饰器的使用：

```text
class Robot {
  @log
  destroyHumans() {
    return `Destroying humans.`;
  }
}

const robot = new Robot();
console.log(robot.destroyHumans());
// LOG: Calling `destroyHumans` function.
// "Destroying humans."
```

日志装饰器自定义日志消息：

```text
class Robot {
  @log('Invoking the function `%s`')
  destroyHumans() {
    return `Destroying humans.`;
  }
}

const robot = new Robot();
console.log(robot.destroyHumans());
// LOG: Invoking the function `destroyHumans`
// "Destroying humans."
```

当robots攻击人类的时候，现在会有日志信息。

### 时间日志装饰器

记录一个函数的执行时间也是装饰器一种很好的用法。为了实现这个目标，我们将在时间记录开始和结束调用之间调用函数，并在最后返回结果。注意我们需要保持对原始函数的引用，用包装函数重写描述符value的属性。

```text
function time(target, name, descriptor) {
  const fn = descriptor.value;

  const decoratedFn = function() {
    console.time(name) ;
    const result = fn.apply(target, arguments);
    console.timeEnd(name);
    return result;
  };

  descriptor.value = decoratedFn;

  return descriptor;
}
```

时间日志装饰器的使用：

```text
class Robot {
  @time
  destroyHumans() {
    let humans = 7e9;
    while (humans--) {
      this.obliterate();
    }

    return `Humans destroyed.`;
  }

  obliterate() {}
}

const robot = new Robot();
console.log(robot.destroyHumans());
// destroyHumans: 7021ms
// Humans destroyed.
```

正如我们所能看到的，机器人需要花大约7秒能毁灭全人类。

### 装饰的装饰器

装饰器能用于包装其他方法。这里是一个简单的装饰装饰器。

```text
function decorate(fn) {
  return (target, name, descriptor) => {
    return {
      configurable: true,
      enumerable: false,
      value: () => {
        return fn(descriptor.value);
      }
    }
  };
}
```

在这个例子中，我们用[memoize](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Memoization)方法包装我们的方法，并且返回缓存的值，或者值被缓存：

```text
function memoize(fn) {
  const cached = memoize.cache[fn];

  if (cached) {
    console.log('Cache hit!');
    return cached;
  }

  const value = fn();
  memoize.cache[fn] = value;

  console.log('Cache miss.');
  return value;
}

memoize.cache = {};

class Robot {
  @decorate(memoize)
  destroyHumans() {
    return 'Humans destroyed.';
  }
}

const robot = new Robot();
console.log(robot.destroyHumans());
// Cache miss.
// Humans destroyed.
console.log(robot.destroyHumans());
// Cache hit!
// Humans destroyed.
```

记忆化在计算量大的时候是很有用的。

### 混合装饰器

利用混合装饰器，我们可以为class添加或混合更多的行为。我将使用混合的对象，扩展class的原型；来包含对象：

```text
function mixin(...mixins) {
  return (target, name, descriptor) => {
    mixins.forEach((obj) => {
      for (const key in obj) {
        const desc = Object.getOwnPropertyDescriptor(obj, key);

        Object.defineProperty(target.prototype, key, desc);
      }
    });

    return descriptor;
  };
}
```

混合装饰器的使用：

```text
const BrainMixin = {
  think() {
    return 'Today is sunny.';
  }
};

const PhilosophyMixin = {
  ponder() {
    return 'What is the meaning of life?';
  }
};

@mixin(BrainMixin, PhilosophyMixin)
class Robot {
  destroyHumans() {
    return 'Humans destroyed.';
  }
}

const robot = new Robot();
console.log(robot.destroyHumans()); // "Humans destroyed."
console.log(robot.think()); // "Today is sunny."
console.log(robot.ponder()); // "What is the meaning of life?"
```

## MVC、MVP、MVVM

MVC，MVP和MVVM都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。不同于设计模式（Design Pattern），只是为了解决一类问题而总结出的抽象方法，一种架构模式往往使用了多种设计模式。

要了解MVC、MVP和MVVM，就要知道它们的相同点和不同点。不同部分是C(Controller)、P(Presenter)、VM(View-Model)，而相同的部分则是MV(Model-View)。

### Model&View

这里有一个可以对数值进行加减操作的组件：上面显示数值，两个按钮可以对数值进行加减操作，操作后的数值会更新显示。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/4badd8fe694272d5a430.png~tplv-t2oaga2asx-watermark.awebp)



我们将依照这个“栗子”，尝试用JavaScript实现简单的具有MVC/MVP/MVVM模式的Web应用。

### Model

Model层用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法。这里我们把需要用到的数值变量封装在Model中，并定义了add、sub、getVal三种操作数值方法。

```
var myapp = {}; // 创建这个应用对象

myapp.Model = function() {
    var val = 0; // 需要操作的数据

    /* 操作数据的方法 */
    this.add = function(v) {
        if (val < 100) val += v;
    };

    this.sub = function(v) {
        if (val > 0) val -= v;
    };

    this.getVal = function() {
        return val;
    };
};
```

### View

View作为视图层，主要负责数据的展示。

```
myapp.View = function() {

    /* 视图元素 */
    var $num = $('#num'),
        $incBtn = $('#increase'),
        $decBtn = $('#decrease');

    /* 渲染数据 */
    this.render = function(model) {
        $num.text(model.getVal() + 'rmb');
    };
};
```

现在通过Model&View完成了数据从模型层到视图层的逻辑。但对于一个应用程序，这远远是不够的，我们还需要响应用户的操作、同步更新View和Model。于是，在MVC中引入了控制器controller，让它来定义用户界面对用户输入的响应方式，它连接模型和视图，用于控制应用程序的流程，处理用户的行为和数据上的改变。

### MVC

> 那时计算机世界天地混沌，浑然一体，然后出现了一个创世者，将现实世界抽象出模型形成model，将人机交互从应用逻辑中分离形成view，然后就有了空气、水、鸡啊、蛋什么的。
> ——《前端MVC变形记》

上个世纪70年代，[美国施乐帕克研究中心](https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Flink%3Furl%3Dux_43rkE1Ythy0RI6WZIB6NZpSbJYxOSzVk1W7LItMteveUBPdAgoegLc2j8zA8XRqZPS0tTwMAKtAXhZ9jTClBFGzj4GV2zstDqWP7kFC3)，就是那个发明图形用户界面(GUI)的公司，开发了[Smalltalk](https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Fitem%2FSmalltalk%2F1379989)编程语言，并开始用它编写图形界面的应用程序。

到了Smalltalk-80这个版本的时候，一位叫Trygve Reenskaug的工程师为Smalltalk设计了MVC（Model-View-Controller）这种架构模式，极大地降低了GUI应用程序的管理难度，而后被大量用于构建桌面和服务器端应用程序。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/9da7ababda36b88a5dd7.png~tplv-t2oaga2asx-watermark.awebp)



如图，实线代表方法调用，虚线代表事件通知。

MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。

#### Model

Model层用来存储业务的数据，一旦数据发生变化，模型将通知有关的视图。

```
myapp.Model = function() {
    var val = 0;

    this.add = function(v) {
        if (val < 100) val += v;
    };

    this.sub = function(v) {
        if (val > 0) val -= v;
    };

    this.getVal = function() {
        return val;
    };

    ／* 观察者模式 *／
    var self = this, 
        views = [];

    this.register = function(view) {
        views.push(view);
    };

    this.notify = function() {
        for(var i = 0; i < views.length; i++) {
            views[i].render(self);
        }
    };
};
```

Model和View之间使用了观察者模式，View事先在此Model上注册，进而观察Model，以便更新在Model上发生改变的数据。

#### View

view和controller之间使用了策略模式，这里View引入了Controller的实例来实现特定的响应策略，比如这个栗子中按钮的 `click` 事件：

```
myapp.View = function(controller) {
    var $num = $('#num'),
        $incBtn = $('#increase'),
        $decBtn = $('#decrease');

    this.render = function(model) {
        $num.text(model.getVal() + 'rmb');
    };

    /*  绑定事件  */
    $incBtn.click(controller.increase);
    $decBtn.click(controller.decrease);
};
```

如果要实现不同的响应的策略只要用不同的Controller实例替换即可。

#### Controller

控制器是模型和视图之间的纽带，MVC将响应机制封装在controller对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。

```
myapp.Controller = function() {
    var model = null,
        view = null;

    this.init = function() {
        /* 初始化Model和View */
        model = new myapp.Model();
        view = new myapp.View(this);

        /* View向Model注册，当Model更新就会去通知View啦 */
        model.register(view);
        model.notify();
    };

    /* 让Model更新数值并通知View更新视图 */
    this.increase = function() {
        model.add(1);
        model.notify();
    };

    this.decrease = function() {
        model.sub(1);
        model.notify();
    };
};
```

这里我们实例化View并向对应的Model实例注册，当Model发生变化时就去通知View做更新，这里用到了观察者模式。

当我们执行应用的时候，使用Controller做初始化：

```
(function() {
    var controller = new myapp.Controller();
    controller.init();
})();
```

可以明显感觉到，MVC模式的业务逻辑主要集中在Controller，而前端的View其实已经具备了独立处理用户事件的能力，当每个事件都流经Controller时，这层会变得**十分臃肿**。而且MVC中View和Controller一般是一一对应的，捆绑起来表示一个组件，视图与控制器间的过于紧密的连接让Controller的复用性成了问题，如果想多个View共用一个Controller该怎么办呢？这里有一个解决方案：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/3a0357c7a96c677dbf37.png~tplv-t2oaga2asx-watermark.awebp)



来把王者荣耀压压惊～其实我想说的是MVP模式...

### MVP

MVP（Model-View-Presenter）是MVC模式的改良，由IBM的子公司Taligent提出。和MVC的相同之处在于：Controller/Presenter负责业务逻辑，Model管理数据，View负责显示。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/7e6efa438bda9cb0073d.png~tplv-t2oaga2asx-watermark.awebp)



虽然在MVC里，View是可以直接访问Model的，但MVP中的View并不能直接使用Model，而是通过为Presenter提供接口，让Presenter去更新Model，再通过观察者模式更新View。

与MVC相比，MVP模式通过解耦View和Model，完全分离视图和模型使职责划分更加清晰；由于View不依赖Model，可以将View抽离出来做成组件，它只需要提供一系列接口提供给上层操作。

#### Model

```
myapp.Model = function() {
    var val = 0;

    this.add = function(v) {
        if (val < 100) val += v;
    };

    this.sub = function(v) {
        if (val > 0) val -= v;
    };

    this.getVal = function() {
        return val;
    };
};
```

Model层依然是主要与业务相关的数据和对应处理数据的方法。

#### View

```
myapp.View = function() {
    var $num = $('#num'),
        $incBtn = $('#increase'),
        $decBtn = $('#decrease');

    this.render = function(model) {
        $num.text(model.getVal() + 'rmb');
    };

    this.init = function() {
        var presenter = new myapp.Presenter(this);

        $incBtn.click(presenter.increase);
        $decBtn.click(presenter.decrease);
    };
};
```

MVP定义了Presenter和View之间的接口，用户对View的操作都转移到了Presenter。比如这里可以让View暴露setter接口以便Presenter调用，待Presenter通知Model更新后，Presenter调用View提供的接口更新视图。

#### Presenter

```
myapp.Presenter = function(view) {
    var _model = new myapp.Model();
    var _view = view;

    _view.render(_model);

    this.increase = function() {
        _model.add(1);
        _view.render(_model);
    };

    this.decrease = function() {
        _model.sub(1);
        _view.render(_model);
    };
};
```

Presenter作为View和Model之间的“中间人”，除了基本的业务逻辑外，还有大量代码需要对从View到Model和从Model到View的数据进行“手动同步”，这样Presenter显得很**重**，维护起来会比较困难。而且由于没有数据绑定，如果Presenter对视图渲染的需求增多，它不得不过多关注特定的视图，一旦视图需求发生改变，Presenter也需要改动。

运行程序时，以View为入口：

```
(function() {
    var view = new myapp.View();
    view.init();
})();
```

### MVVM

MVVM（Model-View-ViewModel）最早由微软提出。ViewModel指 "Model of View"——视图的模型。这个概念曾在一段时间内被前端圈热炒，以至于很多初学者拿jQuery和Vue做对比...



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/1fba28fee8c9c5eeb021.png~tplv-t2oaga2asx-watermark.awebp)



MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它View显示的数据对应的是Model哪一部分即可。

这里我们使用Vue来完成这个栗子。

#### Model

在MVVM中，我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为（格式化数据由View的负责），这里可以把它理解为一个类似json的数据对象。

```
var data = {
    val: 0
};
```

#### View

和MVC/MVP不同的是，MVVM中的View通过使用模板语法来声明式的将数据渲染进DOM，当ViewModel对Model进行更新的时候，会通过数据绑定更新到View。写法如下：

```
<div id="myapp">
    <div>
        <span>{{ val }}rmb</span>
    </div>
    <div>
        <button v-on:click="sub(1)">-</button>
        <button v-on:click="add(1)">+</button>
    </div>
</div>
```

#### ViewModel

ViewModel大致上就是MVC的Controller和MVP的Presenter了，也是整个模式的重点，业务逻辑也主要集中在这里，其中的一大核心就是数据绑定，后面将会讲到。与MVP不同的是，没有了View为Presente提供的接口，之前由Presenter负责的View和Model之间的数据同步交给了ViewModel中的数据绑定进行处理，当Model发生变化，ViewModel就会自动更新；ViewModel变化，Model也会更新。

```
new Vue({
    el: '#myapp',
    data: data,
    methods: {
        add(v) {
            if(this.val < 100) {
                this.val += v;
            }
        },
        sub(v) {
            if(this.val > 0) {
                this.val -= v;
            }
        }
    }
});复制代码
```

整体来看，比MVC/MVP精简了很多，不仅仅简化了业务与界面的依赖，还解决了数据频繁更新（以前用jQuery操作DOM很繁琐）的问题。因为在MVVM中，View不知道Model的存在，ViewModel和Model也察觉不到View，这种低耦合模式可以使开发过程更加容易，提高应用的可重用性。

### 数据绑定

> 双向数据绑定，可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。——《界面之下：还原真实的MV*模式》



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/c507025c2f9a5c9e0c44.png~tplv-t2oaga2asx-watermark.awebp)



在Vue中，使用了双向绑定技术（Two-Way-Data-Binding），就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。

不同的MVVM框架中，实现双向数据绑定的技术有所不同。目前一些主流的前端框架实现数据绑定的方式大致有以下几种：

- 数据劫持 (Vue)
- 发布-订阅模式 (Knockout、Backbone)
- 脏值检查 (Angular)

我们这里主要讲讲Vue。

Vue采用数据劫持&发布-订阅模式的方式，通过ES5提供的 `Object.defineProperty()` 方法来劫持（监控）各属性的 `getter` 、`setter` ，并在数据（对象）发生变动时通知订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。要实现Vue中的双向数据绑定，大致可以划分三个模块：Observer、Compile、Watcher，如图：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/eeb9bbbdf001b43d6002.png~tplv-t2oaga2asx-watermark.awebp)



- Observer 数据监听器
    负责对数据对象的所有属性进行监听（数据劫持），监听到数据发生变化后通知订阅者。
- Compiler 指令解析器
    扫描模板，并对指令进行解析，然后绑定指定事件。
- Watcher 订阅者
    关联Observer和Compile，能够订阅并收到属性变动的通知，执行指令绑定的相应操作，更新视图。Update()是它自身的一个方法，用于执行Compile中绑定的回调，更新视图。

#### 数据劫持

一般对数据的劫持都是通过Object.defineProperty方法进行的，Vue中对应的函数为 `defineReactive` ，其普通对象的劫持的精简版代码如下：

```
var foo = {
  name: 'vue',
  version: '2.0'
}

function observe(data) {
    if (!data || typeof data !== 'object') {
        return
    }
    // 使用递归劫持对象属性
    Object.keys(data).forEach(function(key) {
        defineReactive(data, key, data[key]);
    })
}

function defineReactive(obj, key, value) {
     // 监听子属性 比如这里data对象里的 'name' 或者 'version'
     observe(value)

    Object.defineProperty(obj, key, {
        get: function reactiveGetter() {
            return value
        },
        set: function reactiveSetter(newVal) {
            if (value === newVal) {
                return
            } else {
                value = newVal
                console.log(`监听成功：${value} --> ${newVal}`)
            }
        }
    })
}

observe(foo)
foo.name = 'angular' // “监听成功：vue --> angular”复制代码
```

上面完成了对数据对象的监听，接下来还需要在监听到变化后去通知订阅者，这需要实现一个消息订阅器 `Dep` ，Watcher通过 `Dep` 添加订阅者，当数据改变便触发 `Dep.notify()` ，Watcher调用自己的 `update()` 方法完成视图更新。

## Mobx原理

### 主要概念

#### observable 可观察对象

在 `mobx` 中，我们需要在一个值或一个对象被改变时，触发相应的动作或响应，这种模式就是典型的观察者模式（或发布订阅模式），那么这里一个值或一个对象就是被观察者，动作或者响应充当观察者。

核心思想也比较容易理解，首先进行对象代理（`proxy` 或 `defineProperty`），这样对象就成了`observable`对象；其次观察者在执行主体逻辑时会访问代理对象属性，这时代理对象主动上报（`reportObserved`）自己到观察者的观察对象队列（`observing`）中，同时也会将观察者放入observable对象的观察者队列（`observers`）中，观察者和被观察者相互存有对方的引用，关系正式确立；最后，当设置代理对象属性时，代理对象触发（`reportChanged`）观察者执行主体逻辑。

可能文字描述起来很难弄清楚 `mobx` 的工作原理，所以接下来用代码以及调用链路详细说明。

阅读源码时，首先要清楚这个库的基本使用方式和接口含义，看起源码来才不会茫茫然不知所措，如果再有一份工作原理的调用链路指南，那就相当于铺好了路，自此走向了巅峰。

##### 1、观察者和被观察者如何建立关系

这里先说明 `mobx` 中观察者是谁，`mobx`中观察者有`reaction`和`autorun`，`autorun`是特殊的`reaction`，而`reaction`实现自`derivation`，也就是说`derivation`是基础的观察者；而被观察者就是`observable`对象。

**注： 下文中可观察变量和被观察者都简称 ‘observable’ **

**调用链路**

```
（1）observable收集观察者
reaction = new Reaction() --> reaction.track() --> trackDerivedFunction() --> bindDependencies(derivation) --> addObserver(observable, derivation) --> observable.observers.add(node)  

（2）观察者收集observable
observableValue.get() --> this.reportObserved(observable) --> derivation.newObserving![derivation.unboundDepsCount++] = observable

（3）observable变更时触发derivation执行
observableValue.set() --> this.reportChanged(observable) -->  propagateChanged(this) --> observable.observers.forEach((d) => {d.onBecomeStale()}) --> d.schedule() --> globalState.pendingReactions.push(d) 以及 runReactions() --> reactionScheduler(runReactionsHelper) --> 遍历执行相关联的衍生（derivation.runReaction()） --> this.onInvalidate()即用户定义的逻辑
复制代码
```

##### 2、核心逻辑讲解

###### Reaction

Reaction类中最核心的是`track`方法，track方法中开启了一个事务，在事务中调用`trackDerivedFunction()`执行用户定义的逻辑 fn() 以及进行关系绑定。

```
// 删减后的代码
track(fn: () => void) {
        startBatch()
  
        const result = trackDerivedFunction(this, fn, undefined)
     
        if (this.isDisposed) {
            // disposed during last run. Clean up everything that was bound after the dispose call.
            clearObserving(this)
        }
        
        endBatch()
    }
```

###### derivation

`trackDerivedFunction()`在derivation中定义。

```
function trackDerivedFunction<T>(derivation: IDerivation, f: () => T, context: any) {
    const prevAllowStateReads = allowStateReadsStart(true)
    // pre allocate array allocation + room for variation in deps
    // array will be trimmed by bindDependencies
    // 把 derivation.dependenciesState 和 derivation.observing数组内所有 ob.lowestObserverState 改为    IDerivationState.UP_TO_DATE （0）
    // 先调用 changeDependenciesStateTo0 方法将 derivation 和 observing 置为稳定态 UP_TO_DATE，主要是方便后续判断是否处在收集依赖阶段
    changeDependenciesStateTo0(derivation)
    // 提前为新 observing 申请空间，之后会trim
    derivation.newObserving = new Array(derivation.observing.length + 100)
    // unboundDepsCount记录尚未绑定的数量，observable被观察者观察时通过reportObserved()更新值
    derivation.unboundDepsCount = 0
    derivation.runId = ++globalState.runId
    // 保存Reaction上下文，将当前进行的reaction赋值给globalState.trackingDerivation供bindDependencies依赖收集用
    const prevTracking = globalState.trackingDerivation
    globalState.trackingDerivation = derivation
    let result
    if (globalState.disableErrorBoundaries === true) {
        result = f.call(context)
    } else {
        try {
            // 这一步将会触发 observable 的访问(因为f中会访问可观察对象的属性)，
            // 即我们 ob.name --> $mobx.name.get() (ObservableValue.prototype.get)
            // -->reportObserved(ObservableValue)
            
            //调用track参数中的函数,在mobx-react里就是组件的render方法
            result = f.call(context)
        } catch (e) {
            result = new CaughtException(e)
        }
    }
    //恢复Reaction上下文
    globalState.trackingDerivation = prevTracking
    //Reaction跟Observable建立关系
    bindDependencies(derivation)

    warnAboutDerivationWithoutDependencies(derivation)

    allowStateReadsEnd(prevAllowStateReads)

    return result
}
```

其中`result = f.call(context)`会触发`observable.get()`，上面的调用链路中可以看到`observable.observers.add(node)`这一步将reaction观察者放入observable的观察者对列中。

接下来是Reaction跟Observable建立关系`bindDependencies(derivation)`。

```
function bindDependencies(derivation: IDerivation) {
    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
    // 暂存旧的observable列表
    const prevObserving = derivation.observing
    // 用新的observable列表替换旧的列表
    const observing = (derivation.observing = derivation.newObserving!)
    let lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE

    // Go through all new observables and check diffValue: (this list can contain duplicates):
    //   0: first occurrence, change to 1 and keep it
    //   1: extra occurrence, drop it
    // 遍历所有新的observable，去除重复的observable
    let i0 = 0,
        l = derivation.unboundDepsCount
    for (let i = 0; i < l; i++) {
        // 这里实际上用了双指针方法去重，i0为慢指针，i为快指针
        const dep = observing[i]
        // 跳过重复的值，即diffValue 等于 1的值；当跳过重复的值时i与i0就不相等了，i领先于i0
        if (dep.diffValue === 0) {
            dep.diffValue = 1
            if (i0 !== i) observing[i0] = dep
            i0++
        }

        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
        // not hitting the condition
        if (((dep as any) as IDerivation).dependenciesState > lowestNewObservingDerivationState) {
            lowestNewObservingDerivationState = ((dep as any) as IDerivation).dependenciesState
        }
    }
    observing.length = i0

    derivation.newObserving = null // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)

    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
    //   0: it's not in new observables, unobserve it
    //   1: it keeps being observed, don't want to notify it. change to 0
    // 遍历旧observable列表：
    // diffValue为0表示不在新的observable列表中（每一轮新的observables的diffValue都会被设置为1），在derivation中解除观察；
    // diffValue为1表示该值仍在被观察（每一轮的依赖更新时，假如一个可观察对象dep在之前一轮也在依赖列表中，
    // 此时dep对象是同一个，新的一轮更新newObserving依赖时，diffValue会被更新为1）；
    // 和newObserving去重操作一样巧妙，diffValue的作用很大呀
    l = prevObserving.length
    while (l--) {
        const dep = prevObserving[l]
        if (dep.diffValue === 0) {
            removeObserver(dep, derivation)
        }
        // 新旧遍历之后依旧将diffValue置0，即上面的 first occurrence
        dep.diffValue = 0
    }

    // Go through all new observables and check diffValue: (now it should be unique)
    //   0: it was set to 0 in last loop. don't need to do anything.
    //   1: it wasn't observed, let's observe it. set back to 0
    // 这里需要做这一步操作是因为第一步newObserving过滤后是新增的观察对象，
    // 第二步prevObserving将依赖的diffValue置0，但prevObserving中的依赖已经是addObserver()过的，
    // 所以就需要标记一下（diffValue置0），最后newObserving中的依赖diffValue为1的就进行addObserver()
    while (i0--) {
        const dep = observing[i0]
        if (dep.diffValue === 1) {
            dep.diffValue = 0
            // 给 observableValue 注册 observer
            // value change 时 observable(object, array, set...) 调用 this.atom.reportChanged() 发送通知
            // foreach 通知每个 reaction 调用 onBecomeStale，也就是 schedule 方法

            // 调用链路：value change --> observable设置值set(newVal) --> this.atom.reportChanged() 
            // --> propagateChanged(this) --> observable.observers.forEach调用observer.onBecomeStale() 
            // --> reaction.schedule() --> globalState.pendingReactions.push(this)以及runReactions() 
            // --> reactionScheduler() 
            // --> allReactions.forEach()执行每个reaction的reaction.runReaction() 
            // --> 执行每个reaction的this.onInvalidate()
            addObserver(dep, derivation)
        }
    }
    // NOTE: 收集完的依赖保存到 reaction.observing 中，在 getDependencyTree api 中会调用到

    // 对于新添加的观察数据，将 derivation 添加 globalState.pendingReactions 中，
    // 在当前事务周期中处理
    // Some new observed derivations may become stale during this derivation computation
    // so they have had no chance to propagate staleness (#916)
    if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) {
        derivation.dependenciesState = lowestNewObservingDerivationState
        derivation.onBecomeStale()
    }
}
```

了解了衍生后，还有一个重要的知识点是`状态`，状态代表了衍生和可观察对象的不同阶段，通过状态可以更好地控制逻辑的执行。衍生或可观察对象有四个状态，值越高表示越不稳定：

`NOT_TRACKING`：初始时或衍生不再订阅可观察对象时的状态

`UP_TO_DATE`：表示当前的值是最新的或者衍生的依赖未发生变化，不需要重新计算

`POSSIBLY_STALE`：计算值的依赖发生变化时的状态，表示计算值可能有变更；比如计算值`a`依赖了`observable b` 和`observable c`，如果这时`b`和`c`都发生了变化，但最终的结果`a`未发生变化，那就不需要通知`a`的观察者`observers`执行逻辑了

`STALE`：表示衍生的逻辑需要重新执行，这时衍生依赖的对象发生了变更

```
enum IDerivationState {
    NOT_TRACKING = -1,
    UP_TO_DATE = 0,
    POSSIBLY_STALE = 1,
    STALE = 2
}
```

###### observable

对象经过 `mobx` 处理后变成可观察对象，这里的处理是指通过 `proxy`或者 `defineProperty` 代理。在`mobx`中一个基础类型的值可以成为`observable`，一个`array` /`map` / `set` / `object`也可以成为`observable`，但他们的处理方式有一些差别，具体看下文分析。

我们用装饰器方式作用变量时：

```
import { observable } from "mobx"

class Todo {

  id = Math.random()

  @observable title = ""

  @observable finished = false

}
```

`observable`实际调用了`createObservable`函数，而`createObservable`中又调用了`observable`的方法。

`observable`有什么方法呢，先看它的类型。

```
const observable: IObservableFactory & IObservableFactories & { enhancer: IEnhancer<any>}
```

其中`IObservableFactories`是个接口，`observableFactories`是它的具体实现，对基本数据类型以及对象进行代理和劫持。

```
const observableFactories: IObservableFactories = {
    // 对于基本类型 string, boolean, number 可以用 box 来劫持
    box<T = any>(value?: T, options?: CreateObservableOptions): IObservableValue<T> {
        if (arguments.length > 2) incorrectlyUsedAsDecorator("box")
        const o = asCreateObservableOptions(options)
        //  getEnhancerFromOptions(o) 生成enhancer
        return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals)
    },
    array<T = any>(initialValues?: T[], options?: CreateObservableOptions): IObservableArray<T> {
        if (arguments.length > 2) incorrectlyUsedAsDecorator("array")
        const o = asCreateObservableOptions(options)
        return createObservableArray(initialValues, getEnhancerFromOptions(o), o.name) as any
    },
    map<K = any, V = any>(
        initialValues?: IObservableMapInitialValues<K, V>,
        options?: CreateObservableOptions
    ): ObservableMap<K, V> {
        if (arguments.length > 2) incorrectlyUsedAsDecorator("map")
        const o = asCreateObservableOptions(options)
        return new ObservableMap<K, V>(initialValues, getEnhancerFromOptions(o), o.name)
    },
    set<T = any>(
        initialValues?: IObservableSetInitialValues<T>,
        options?: CreateObservableOptions
    ): ObservableSet<T> {
        if (arguments.length > 2) incorrectlyUsedAsDecorator("set")
        const o = asCreateObservableOptions(options)
        return new ObservableSet<T>(initialValues, getEnhancerFromOptions(o), o.name)
    },
    object<T = any>(
        props: T,
        decorators?: { [K in keyof T]: Function },
        options?: CreateObservableOptions
    ): T & IObservableObject {
        if (typeof arguments[1] === "string") incorrectlyUsedAsDecorator("object")
        const o = asCreateObservableOptions(options)
        if (o.proxy === false) {
            // 采用Object.defineProperty劫持
            return extendObservable({}, props, decorators, o) as any
        } else {
            const defaultDecorator = getDefaultDecoratorFromObjectOptions(o)
            // extendObservable中会将adm赋值给属性$mobx，以供proxy代理时调用
            const base = extendObservable({}, undefined, undefined, o) as any
            const proxy = createDynamicObservableObject(base)
            extendObservableObjectWithProperties(proxy, props, decorators, defaultDecorator)
            return proxy
        }
    },
    ref: refDecorator,
    shallow: shallowDecorator,
    deep: deepDecorator,
    struct: refStructDecorator
} as any
```

那既然`observableFactories`定义了数据类型的劫持方法，那怎么让observable也有同样的功能，接下来看：

```
Object.keys(observableFactories).forEach(name => (observable[name] = observableFactories[name]))
```

明白了吧。

回到刚才所说的`observable`实际调用了`createObservable`函数：

里面对传入的值或对象进行分类别劫持。

```
function createObservable(v: any, arg2?: any, arg3?: any) {
    // @observable someProp;
    if (typeof arguments[1] === "string" || typeof arguments[1] === "symbol") {
        return deepDecorator.apply(null, arguments as any)
    }

    // it is an observable already, done
    if (isObservable(v)) return v

    // something that can be converted and mutated?
    const res = isPlainObject(v)
        ? observable.object(v, arg2, arg3)
        : Array.isArray(v)
        ? observable.array(v, arg2)
        : isES6Map(v)
        ? observable.map(v, arg2)
        : isES6Set(v)
        ? observable.set(v, arg2)
        : v

    // this value could be converted to a new observable data structure, return it
    if (res !== v) return res
}
```

###### object的劫持

object 函数接收三个参数，第三个参数为 options 可以定制化劫持方式。

使用示例：

```
const person = observable({
    name: 'lawler',
    get labelText() {
        return this.showAge ? `${this.name} (age: ${this.age})` : this.name;
    },
    setAge(age) {
        his.age = age;
    }
}, { 
    // 此为第二个参数 decorators
    // setAge设置为action类型，其他属性默认为 observables / computed
    setAge: action 

} /*, 这里传第三个 options 参数 *\/);
```

来看看它是怎么实现的：

```
object<T = any>(
        props: T,
        decorators?: { [K in keyof T]: Function },
        options?: CreateObservableOptions
    ): T & IObservableObject {
        if (typeof arguments[1] === "string") incorrectlyUsedAsDecorator("object")
        const o = asCreateObservableOptions(options)
        if (o.proxy === false) {
            // 采用Object.defineProperty劫持
            return extendObservable({}, props, decorators, o) as any
        } else {
            const defaultDecorator = getDefaultDecoratorFromObjectOptions(o)
            // extendObservable中会将adm赋值给属性$mobx，以供proxy代理时调用
            const base = extendObservable({}, undefined, undefined, o) as any
            const proxy = createDynamicObservableObject(base)
            extendObservableObjectWithProperties(proxy, props, decorators, defaultDecorator)
            return proxy
        }
```

第一步：生成配置选项

如果`options`传入的是个字符串，那么

```
const o = { name: thing, deep: true, proxy: true }
```

如果不传任何配置项，则返回默认配置项，所以默认是用proxy代理劫持

```
const defaultCreateObservableOptions = {
    deep: true,
    name: undefined,
    defaultDecorator: undefined,
    proxy: true
}
```

第二步： 生成默认装饰器

```
const defaultDecorator = getDefaultDecoratorFromObjectOptions(o) 默认项返回 deepDecorator
```

默认的 `deepDecorator`代码部分：

```
const deepDecorator = createDecoratorForEnhancer(deepEnhancer)

// 删除了一些开发环境的代码
function createDecoratorForEnhancer(enhancer: IEnhancer<any>): IObservableDecorator {
    invariant(enhancer)
    const decorator = createPropDecorator(
        true,
        (
            target: any,
            propertyName: PropertyKey,
            descriptor: BabelDescriptor | undefined,
            _decoratorTarget,
            decoratorArgs: any[]
        ) => {
            const initialValue = descriptor
                ? descriptor.initializer
                    ? descriptor.initializer.call(target)
                    : descriptor.value
                : undefined
            /**
             * asObservableObject，其传入参数为原始对象，
             * 返回值是ObservableObjectAdministration类型对象adm
             * 同时将adm绑定到$mobx属性上，共对象使用
             * 
             * 并且链式调用了 addObservableProp，
             * 通过 enhancer，把 propertyName 属性赋上劫持后的 initialValue
             */
            asObservableObject(target).addObservableProp(propertyName, initialValue, enhancer)
        }
    )
   
    const res: any = decorator
    res.enhancer = enhancer
    return res
}
```

重点在`asObservableObject(target).addObservableProp(propertyName, initialValue, enhancer)`中。

首先是`asObservableObject`：

这个方法的作用是生成一个`adm`对象并返回，同时将`adm`赋值到对象的`$mobx`属性中，供对象使用。

```
export function asObservableObject(
    target: any,
    name: PropertyKey = "",
    defaultEnhancer: IEnhancer<any> = deepEnhancer
): ObservableObjectAdministration {
    if (Object.prototype.hasOwnProperty.call(target, $mobx)) return target[$mobx]

    if (!isPlainObject(target))
        name = (target.constructor.name || "ObservableObject") + "@" + getNextId()
    if (!name) name = "ObservableObject@" + getNextId()

    const adm = new ObservableObjectAdministration(
        target,
        new Map(),
        stringifyKey(name),
        defaultEnhancer
    )
    addHiddenProp(target, $mobx, adm)
    return adm
}
```

而`ObservableObjectAdministration`封装了一些read、write、has等方法

```
/**
 * 可以看出 adm 其实也是个封装类，具体围绕 values 展开，
 * 而 values 是个 Map，键为 PropertyKey，值为 ObservableValue像 read，write 等方法，
 * 最后都是调用的 ObservableValue 提供的 api
 */
class ObservableObjectAdministration
    constructor(
        public target: any,
        public values = new Map<PropertyKey, ObservableValue<any> | ComputedValue<any>>(),
        public name: string,
        public defaultEnhancer: IEnhancer<any>
    ) {
        this.keysAtom = new Atom(name + ".keys")
    }

    read(key: PropertyKey) {
        return this.values.get(key)!.get()
    }

    write(key: PropertyKey, newValue) {
        // 省略
    }

    has(key: PropertyKey) {
        // 省略
    }

    addObservableProp(
        propName: PropertyKey,
        newValue,
        enhancer: IEnhancer<any> = this.defaultEnhancer
    ) {
        // 省略
    }

    addComputedProp(
        propertyOwner: any, // where is the property declared?
        propName: PropertyKey,
        options: IComputedValueOptions<any>
    ) {
       // 省略
    }

    remove(key: PropertyKey) {
        // 省略
    }

    observe(callback: (changes: IObjectDidChange) => void, fireImmediately?: boolean): Lambda {
        return registerListener(this, callback)
    }
}
```

接下来调用`adm.addObservableProp(propertyName, initialValue, enhancer)`：

为observable对象添加属性并劫持set / get操作；同时也将 initialValue 变成 ObservableValue，最后以属性名为键值存入adm.values对象中（实际的proxy代理时会用到，看下文）。

```
 addObservableProp(
        propName: PropertyKey,
        newValue,
        enhancer: IEnhancer<any> = this.defaultEnhancer
    ) {
        // this为adm
        const { target } = this
        assertPropertyConfigurable(target, propName)

        const observable = new ObservableValue(
            newValue,
            enhancer,
            `${this.name}.${stringifyKey(propName)}`,
            false
        )
        
        this.values.set(propName, observable)
        newValue = (observable as any).value // observableValue might have changed it

        Object.defineProperty(target, propName, generateObservablePropConfig(propName))
        this.notifyPropertyAddition(propName, newValue)
    }
```

第三步：base对象为一个空对象，但属性`$mobx`值为`adm`对象

```
const base = extendObservable({}, undefined, undefined, o) as any
复制代码
function extendObservable<A extends Object, B extends Object>(
    target: A,
    properties?: B,
    decorators?: { [K in keyof B]?: Function },
    options?: CreateObservableOptions
): A & B {
    options = asCreateObservableOptions(options)
    const defaultDecorator = getDefaultDecoratorFromObjectOptions(options)
    //  这里target是空对象‘{}’
    initializeInstance(target) 
    // target的属性$mobx值为adm对象
    asObservableObject(target, options.name, defaultDecorator.enhancer) // make sure object is observable, even without initial props
    if (properties)
        extendObservableObjectWithProperties(target, properties, decorators, defaultDecorator)
    return target as any
}
```

第四步： 代理对象

```
const proxy = createDynamicObservableObject(base)

function createDynamicObservableObject(base) {
    // objectProxyTraps中定义了代理的属性(has/get/set等)，其实还是调用了adm对象的方法
    const proxy = new Proxy(base, objectProxyTraps)
    base[$mobx].proxy = proxy
    return proxy
}
```

在`objectProxyTraps`的get方法中，会从`adm.values.get(name)`取出`observable`使用。

```
 get(target: IIsObservableObject, name: PropertyKey) {
        if (name === $mobx || name === "constructor" || name === mobxDidRunLazyInitializersSymbol)
            return target[name]
        const adm = getAdm(target)
        const observable = adm.values.get(name)
        if (observable instanceof Atom) {
            const result = (observable as any).get()
            if (result === undefined) {
                // This fixes #1796, because deleting a prop that has an
                // undefined value won't retrigger a observer (no visible effect),
                // the autorun wouldn't subscribe to future key changes (see also next comment)
                adm.has(name as any)
            }
            return result
        }
        // make sure we start listening to future keys
        // note that we only do this here for optimization
        if (isPropertyKey(name)) adm.has(name)
        return target[name]
    }
```

第五步：对属性进行处理，用各自的装饰器包裹

```
extendObservableObjectWithProperties(proxy, props, decorators, defaultDecorator)
```

这段代码的作用就是将对象的各种属性经过相应的装饰器包裹以后再赋值给对象的代理proxy的属性。

```
function extendObservableObjectWithProperties(
    target,
    properties,
    decorators,
    defaultDecorator
) {
    startBatch()
    try {
        const keys = getPlainObjectKeys(properties)
        for (const key of keys) {
            const descriptor = Object.getOwnPropertyDescriptor(properties, key)!
            
            const decorator =
                decorators && key in decorators
                    ? decorators[key]
                    : descriptor.get
                    ? computedDecorator
                    : defaultDecorator

            const resultDescriptor = decorator!(target, key, descriptor, true)
            if (
                resultDescriptor // otherwise, assume already applied, due to `applyToInstance`
            )
                Object.defineProperty(target, key, resultDescriptor)
        }
    } finally {
        endBatch()
    }
}
```

其中当`decorator`是用户定义的装饰器类别，这里有计算值装饰器`computedDecorator`, action类别的装饰器以及默认的`defaultDecorator`observable装饰器。

这里只讲一下action装饰器，其他的也比较容易理解。

在上面的使用示例中`setAge: action`,`decorator`就是`action`。

上代码：

```
const action: IActionFactory = function action(arg1, arg2?, arg3?, arg4?): any {
    // action(fn() {})
    if (arguments.length === 1 && typeof arg1 === "function")
        return createAction(arg1.name || "<unnamed action>", arg1)
    // action("name", fn() {})
    if (arguments.length === 2 && typeof arg2 === "function") return createAction(arg1, arg2)

    // @action("name") fn() {}
    if (arguments.length === 1 && typeof arg1 === "string") return namedActionDecorator(arg1)

    // @action fn() {}
    if (arg4 === true) {
        // apply to instance immediately
        addHiddenProp(arg1, arg2, createAction(arg1.name || arg2, arg3.value, this))
    } else {
        return namedActionDecorator(arg2).apply(null, arguments as any)
    }
} as any
```

这里我们传入了四个参数，且`arg4 === true`，进入`addHiddenProp`，作用是`增加对象的不可遍历属性`

```
function addHiddenProp(object: any, propName: PropertyKey, value: any) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: true,
        configurable: true,
        value
    })
}
```

接着我们看看`createAction`做了什么：

`createAction`返回一个函数， 而这个函数的返回值是执行`descriptor`的结果，即是上面示例中`setAge()`的执行结果。

```
function createAction(actionName: string, fn: Function, ref?: Object): Function & IAction {
    const res = function() {
        // 首先将runInfo等信息保存起来，然后执行 fn ，最后恢复刚才保存的信息并且会调用endBatch()
        return executeAction(actionName, fn, ref || this, arguments)
    }
    ;(res as any).isMobxAction = true
   
    return res as any
}

function executeAction(actionName: string, fn: Function, scope?: any, args?: IArguments) {
    // 将derivation等信息保存起来，在_endAction()中恢复
    const runInfo = _startAction(actionName, scope, args)
    try {
        return fn.apply(scope, args)
    } catch (err) {
        runInfo.error = err
        throw err
    } finally {
        _endAction(runInfo)
    }
}
```

好了，现在回过头看看 mobx 文档中定义的`action`:

> 它接收一个函数并返回具有同样签名的函数，但是用 `transaction`、`untracked` 和 `allowStateChanges` 包裹起来，尤其是 `transaction` 的自动应用会产生巨大的性能收益， 动作会分批处理变化并只在(最外层的)动作完成后通知计算值和反应。 这将确保在动作完成之前，在动作期间生成的中间值或未完成的值对应用的其余部分是不可见的。

这里的`transaction`是指`_startAction`和`_endAction`中开启的事务`startBatch()`和`endBatch()`，在事务处理期间`globalState.trackingDerivation = null`，意味着action处理期间不进行依赖收集（即描述中的`untracked` ，因为执行action可能访问observable的属性，触发get代理，上文中说到get代理会进行依赖收集，但action是不需要进行依赖收集的，它仅仅是执行一个动作）；在`endBatch()`中接着执行`runReactions()`（即描述中所说的`动作完成后通知计算值和反应`）； `allowStateChanges` 就比较好理解了，是控制observable对象是否只能在action中变更值，细节可以在文件`configure.ts`中查看。

那么`addHiddenProp(arg1, arg2, createAction(arg1.name || arg2, arg3.value, this))`就是把action类别的动作用装饰器action包裹起来再丢给proxy对象。

所以，observable.object(对象，装饰器， 配置项)最终会产生一个新的对象，这个新的对象是个代理对象。

###### array的劫持

看完了复杂额度object的代理，那么很多概念都已经有了了解，其他类型的对象就容易很多。

代理array调用了`createObservableArray`函数。

```
function createObservableArray<T>(
    initialValues: any[] | undefined,
    enhancer: IEnhancer<T>,
    name = "ObservableArray@" + getNextId(),
    owned = false
): IObservableArray<T> {
    const adm = new ObservableArrayAdministration(name, enhancer, owned)
    addHiddenFinalProp(adm.values, $mobx, adm)
    const proxy = new Proxy(adm.values, arrayTraps) as any
    adm.proxy = proxy
    if (initialValues && initialValues.length) {
        const prev = allowStateChangesStart(true)
        // 初始化
        adm.spliceWithArray(0, 0, initialValues)
        allowStateChangesEnd(prev)
    }
    return proxy
}
```

第一步：创建`adm`对象，后面的操作都是调用 adm 中的方法；

这里面最重要的方法是`spliceWithArray`，相当于拦截了数组的`splice`操作，对新加入的元素进行`enhancer`劫持，删除的元素`dehancer`处理，最后通知数组发生了变更`reportChanged()`。

```
class ObservableArrayAdministration
    implements IInterceptable<IArrayWillChange<any> | IArrayWillSplice<any>>, IListenable {
    atom: IAtom
    values: any[] = []
    interceptors
    changeListeners
    enhancer: (newV: any, oldV: any | undefined) => any
    dehancer: any
    proxy: any[] = undefined as any
    lastKnownLength = 0

    constructor(name, enhancer: IEnhancer<any>, public owned: boolean) {
        this.atom = new Atom(name || "ObservableArray@" + getNextId())
        this.enhancer = (newV, oldV) => enhancer(newV, oldV, name + "[..]")
    }

    getArrayLength(): number {
        this.atom.reportObserved()
        return this.values.length
    }

    setArrayLength(newLength: number) {
        if (typeof newLength !== "number" || newLength < 0)
            throw new Error("[mobx.array] Out of range: " + newLength)
        let currentLength = this.values.length
        if (newLength === currentLength) return
        else if (newLength > currentLength) {
            const newItems = new Array(newLength - currentLength)
            for (let i = 0; i < newLength - currentLength; i++) newItems[i] = undefined // No Array.fill everywhere...
            this.spliceWithArray(currentLength, 0, newItems)
        } else this.spliceWithArray(newLength, currentLength - newLength)
    }

    updateArrayLength(oldLength: number, delta: number) {
        if (oldLength !== this.lastKnownLength)
            throw new Error(
                "[mobx] Modification exception: the internal structure of an observable array was changed."
            )
        this.lastKnownLength += delta
    }

    spliceWithArray(index: number, deleteCount?: number, newItems?: any[]): any[] {
        checkIfStateModificationsAreAllowed(this.atom)
        const length = this.values.length

        if (index === undefined) index = 0
        else if (index > length) index = length
        // inedx小于0则从list尾部取值
        else if (index < 0) index = Math.max(0, length + index)

        if (arguments.length === 1) deleteCount = length - index
        else if (deleteCount === undefined || deleteCount === null) deleteCount = 0
        // Math.min(deleteCount, length - index) 防止删除的数量超过数组长度
        else deleteCount = Math.max(0, Math.min(deleteCount, length - index))

        if (newItems === undefined) newItems = EMPTY_ARRAY

        if (hasInterceptors(this)) {
            const change = interceptChange<IArrayWillSplice<any>>(this as any, {
                object: this.proxy as any,
                type: "splice",
                index,
                removedCount: deleteCount,
                added: newItems
            })
            if (!change) return EMPTY_ARRAY
            deleteCount = change.removedCount
            newItems = change.added
        }

        // 对新值用 enhancer 进行劫持
        newItems = newItems.length === 0 ? newItems : newItems.map(v => this.enhancer(v, undefined))
        
        // 将劫持后的 array 更新到 this.values 中
        // res 为删除后的元素数组
        const res = this.spliceItemsIntoValues(index, deleteCount, newItems)

        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res)
        // 对删除后的元素进行 dehancer 处理
        return this.dehanceValues(res)
    }

    spliceItemsIntoValues(index, deleteCount, newItems: any[]): any[] {
        if (newItems.length < MAX_SPLICE_SIZE) {
            // splice返回删除的元素
            return this.values.splice(index, deleteCount, ...newItems)
        } else {
            // res为删除的元素
            const res = this.values.slice(index, index + deleteCount)
            this.values = this.values
                .slice(0, index)
                .concat(newItems, this.values.slice(index + deleteCount))
            return res
        }
    }

    notifyArrayChildUpdate(index: number, newValue: any, oldValue: any) {
        // 省略...
        this.atom.reportChanged()
    }

    notifyArraySplice(index: number, added: any[], removed: any[]) {
        // 省略...
        this.atom.reportChanged()
    }
}
```

第二步：将adm丢给`adm.values`的属性`$mobx`；

```
addHiddenFinalProp(adm.values, $mobx, adm)
```

第三步：代理对象

```
const proxy = new Proxy(adm.values, arrayTraps)
```

其中代理的get、set方法在`arrayTraps`中，

```
const arrayTraps = {
    get(target, name) {
        if (name === $mobx) return target[$mobx]
        if (name === "length") return target[$mobx].getArrayLength()
        if (typeof name === "number") {
            return arrayExtensions.get.call(target, name)
        }
        if (typeof name === "string" && !isNaN(name as any)) {
            return arrayExtensions.get.call(target, parseInt(name))
        }
        if (arrayExtensions.hasOwnProperty(name)) {
            return arrayExtensions[name]
        }
        return target[name]
    },
    set(target, name, value): boolean {
        if (name === "length") {
            target[$mobx].setArrayLength(value)
        }
        if (typeof name === "number") {
            arrayExtensions.set.call(target, name, value)
        }
        if (typeof name === "symbol" || isNaN(name)) {
            target[name] = value
        } else {
            // numeric string
            arrayExtensions.set.call(target, parseInt(name), value)
        }
        return true
    },
    preventExtensions(target) {
        fail(`Observable arrays cannot be frozen`)
        return false
    }
}
```

可以看到除了一如既往地调用`adm`的方法外，还用到了`arrayExtensions`，它封装了数组的基本操作，本质和是哪个还是调用了`adm`的方法。

```
// 全部调用对象上的属性$mobx值---adm来对values操作
const arrayExtensions = {
        intercept(handler: IInterceptor<IArrayWillChange<any> | IArrayWillSplice<any>>): Lambda {
            return this[$mobx].intercept(handler)
        },
        observe(
            listener: (changeData: IArrayChange<any> | IArraySplice<any>) => void,
            fireImmediately = false
        ): Lambda {
            const adm: ObservableArrayAdministration = this[$mobx]
            return adm.observe(listener, fireImmediately)
        },
        clear(): any[] {
            return this.splice(0)
        },
        replace(newItems: any[]) {
            const adm: ObservableArrayAdministration = this[$mobx]
            return adm.spliceWithArray(0, adm.values.length, newItems)
        },
        toJS(): any[] {
            return (this as any).slice()
        },
        toJSON(): any[] {
            // Used by JSON.stringify
            return this.toJS()
        },

        splice(index: number, deleteCount?: number, ...newItems: any[]): any[] {
            const adm: ObservableArrayAdministration = this[$mobx]
            switch (arguments.length) {
                case 0:
                    return []
                case 1:
                    return adm.spliceWithArray(index)
                case 2:
                    return adm.spliceWithArray(index, deleteCount)
            }
            return adm.spliceWithArray(index, deleteCount, newItems)
        },

        spliceWithArray(index: number, deleteCount?: number, newItems?: any[]): any[] {
            const adm: ObservableArrayAdministration = this[$mobx]
            return adm.spliceWithArray(index, deleteCount, newItems)
        },

        push(...items: any[]): number {
            const adm: ObservableArrayAdministration = this[$mobx]
            adm.spliceWithArray(adm.values.length, 0, items)
            return adm.values.length
        },

        pop() {
            return this.splice(Math.max(this[$mobx].values.length - 1, 0), 1)[0]
        },

        shift() {
            return this.splice(0, 1)[0]
        },

        unshift(...items: any[]): number {
            const adm = this[$mobx]
            adm.spliceWithArray(0, 0, items)
            return adm.values.length
        },

        reverse(): any[] {
            const clone = (<any>this).slice()
            return clone.reverse.apply(clone, arguments)
        },

        sort(compareFn?: (a: any, b: any) => number): any[] {
            const clone = (<any>this).slice()
            return clone.sort.apply(clone, arguments)
        },

        remove(value: any): boolean {
            const adm: ObservableArrayAdministration = this[$mobx]
            const idx = adm.dehanceValues(adm.values).indexOf(value)
            if (idx > -1) {
                this.splice(idx, 1)
                return true
            }
            return false
        },

        get(index: number): any | undefined {
            const adm: ObservableArrayAdministration = this[$mobx]
            if (adm) {
                if (index < adm.values.length) {
                    adm.atom.reportObserved()
                    return adm.dehanceValue(adm.values[index])
                }
            }
            return undefined
        },

        set(index: number, newValue: any) {
            const adm: ObservableArrayAdministration = this[$mobx]
            const values = adm.values
            if (index < values.length) {
                // update at index in range
                checkIfStateModificationsAreAllowed(adm.atom)
                const oldValue = values[index]
                if (hasInterceptors(adm)) {
                    const change = interceptChange<IArrayWillChange<any>>(adm as any, {
                        type: "update",
                        object: adm.proxy as any, // since "this" is the real array we need to pass its proxy
                        index,
                        newValue
                    })
                    if (!change) return
                    newValue = change.newValue
                }
                newValue = adm.enhancer(newValue, oldValue)
                const changed = newValue !== oldValue
                if (changed) {
                    values[index] = newValue
                    adm.notifyArrayChildUpdate(index, newValue, oldValue)
                }
            } else if (index === values.length) {
                // add a new item
                adm.spliceWithArray(index, 0, [newValue])
            } else {
                // out of bounds
                throw new Error(
                    `[mobx.array] Index out of bounds, ${index} is larger than ${values.length}`
                )
            }
        }
    }
```

数组还有一些内置的方法， mobx 做了进一步处理，都放到`arrayExtensions`中。

```
;[
    "concat",
    "every",
    "filter",
    "forEach",
    "indexOf",
    "join",
    "lastIndexOf",
    "map",
    "reduce",
    "reduceRight",
    "slice",
    "some",
    "toString",
    "toLocaleString"
].forEach(funcName => {
    arrayExtensions[funcName] = function() {
        const adm: ObservableArrayAdministration = this[$mobx]
        // atom 中有reportObserved和reportChanged函数
        adm.atom.reportObserved()
        const res = adm.dehanceValues(adm.values)
        return res[funcName].apply(res, arguments)
    }
})
```

数组对象被代理后拥有了依赖收集，变更通知的功能，就可以和derivation一起工作了。

###### map的劫持

`ObservableMap`的代码冗长，一步步拆解分析。

先来看看它的构造函数：

`this._data`是`initialData`的代理对象。

`this._hasMap`是缓存map中keys的变化--新增还是删除状态。

```
 constructor(
        initialData?: IObservableMapInitialValues<K, V>,
        public enhancer: IEnhancer<V> = deepEnhancer,
        public name = "ObservableMap@" + getNextId()
    ) {
        this._data = new Map()
        // this.get()中会调用this.has()
        // this.has()中会调用this._hasMap.set()设置值
        // 所以只有当observerableMap.get('xxx')时，_hasMap中才会存有‘xxx’属性和值
        // 当在map中新增属性或者删除属性时会调用_updateHasMapEntry()，
        // _updateHasMapEntry()的作用是设置新增属性'xxx'时其value值为'true', 删除'xxx'时其value值为'false'
        // 例如autorun(() => console.log(counterStore.testMap.get('xxx')));
        // 这时，_hasMap中存有值了；

        // 但如果在store中@action func() {this.testMap.get('xxx')}，
        // 这样是不会把‘xxx’放入_hasMap中的

        // 总结：_hasMap用来存储新增或删除的keys（仅在autorun这类型的reaction中才生效）
        // 因而_hasMap是缓存map中keys的变化--新增还是删除状态
        this._hasMap = new Map()
        // 将初始数据的属性和值赋值给this._data
        // merge时会调用this.set()-->this._addValue()，使得_data属性变成ObservableValue
        this.merge(initialData)
    }
```

关键看`thie.merge(initialData)`， 就是把`initialData`遍历赋值给`this._data`，如果是新增属性，先把值变成`observable`对象，接着通知变更`reportChanged()`，触发derivation；如果是update值，将新值用`enhancer`处理后通知变更`this.reportChanged()`。

```
// 将other对象的属性依次赋值给this对象，并返回this
merge(other: ObservableMap<K, V> | IKeyValueMap<V> | any): ObservableMap<K, V> {
    if (isObservableMap(other)) {
    	other = other.toJS()
	}
    // transaction开启一个事务，在事务执行期间视图view不会更新，是一个同步执行的过程
    transaction(() => {
        if (isPlainObject(other))
            getPlainObjectKeys(other).forEach(key => this.set((key as any) as K, other[key]))
        else if (Array.isArray(other)) other.forEach(([key, value]) => this.set(key, value))
        else if (isES6Map(other)) {
            if (other.constructor !== Map)
                fail("Cannot initialize from classes that inherit from Map: " + other.constructor.name)
            other.forEach((value, key) => this.set(key, value))
        } else if (other !== null && other !== undefined)
            fail("Cannot initialize map from " + other)
    })
    return this
}

set(key: K, value: V) {
    const hasKey = this._has(key)

    if (hasKey) {
        this._updateValue(key, value)
    } else {
        this._addValue(key, value)
    }
    return this
}

private _updateValue(key: K, newValue: V | undefined) {
    const observable = this._data.get(key)!
          newValue = (observable as any).prepareNewValue(newValue) as V
          if (newValue !== globalState.UNCHANGED) {
              observable.setNewValue(newValue as V)
          }
}

private _addValue(key: K, newValue: V) {
    checkIfStateModificationsAreAllowed(this._keysAtom)
    transaction(() => {
        const observable = new ObservableValue(
            newValue,
            this.enhancer,
            `${this.name}.${stringifyKey(key)}`,
            false
        )
        this._data.set(key, observable)
        newValue = (observable as any).value // value might have been changed
        this._updateHasMapEntry(key, true)
        this._keysAtom.reportChanged()
    })
}
```

`ObservableMap`中还定义了`replace`、`clear`以及`entries`等map方法，相当于劫持了原生map的方法。

###### set的劫持

照例，先看它的构造函数做了什么：

```
constructor(
        initialData?: IObservableSetInitialValues<T>,
        enhancer: IEnhancer<T> = deepEnhancer,
        public name = "ObservableSet@" + getNextId()
    ) {
        if (typeof Set !== "function") {
            throw new Error(
                "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js"
            )
        }

        this.enhancer = (newV, oldV) => enhancer(newV, oldV, name)

        if (initialData) {
            this.replace(initialData)
        }
    }
```

重新定义了`enhancer`函数，以及处理`initialData`。

```
 replace(other: ObservableSet<T> | IObservableSetInitialValues<T>): ObservableSet<T> {
        if (isObservableSet(other)) {
            other = other.toJS()
        }

        transaction(() => {
            if (Array.isArray(other)) {
                this.clear()
                other.forEach(value => this.add(value))
            } else if (isES6Set(other)) {
                this.clear()
                other.forEach(value => this.add(value))
            } else if (other !== null && other !== undefined) {
                fail("Cannot initialize set from " + other)
            }
        })

        return this
    }
```

`replace`很简单，做了一些判断，最后调用`add`函数：

又看到熟悉的`this._data`，和`ObservableMap`中的作用一样。

`add`函数也简单，`enhancer`处理后放入`this._data`中，最后上报变更。

```
add(value: T) {
    checkIfStateModificationsAreAllowed(this._atom)
    if (!this.has(value)) {
        transaction(() => {
            this._data.add(this.enhancer(value, undefined))
            this._atom.reportChanged()
        })
    }

    return this
}
```

###### 基本数据类型的劫持

string，boolean， number 用 box 劫持，最终是调用`ObservableValue()`。

用`enhancer`处理后覆盖原来的值。

当然`ObservableValue`类也代理了get和set操作。

```
constructor(
        value: T,
        public enhancer: IEnhancer<T>,
        public name = "ObservableValue@" + getNextId(),
        notifySpy = true,
        private equals: IEqualsComparer<any> = comparer.default
    ) {
        super(name)
        this.value = enhancer(value, undefined, name)
    }
```

###### computedValue

先看看使用示例：

```
class OrderLine {
    @observable price = 0;
    @observable amount = 1;

    constructor(price) {
        this.price = price;
    }

    @computed get total() {
        return this.price * this.amount;
    }
}
```

另外，`observable.object` 和 `extendObservable` 都会自动将 getter 属性推导成计算属性，所以下面这样就足够了:

```
const orderLine = observable.object({
    price: 0,
    amount: 1,
    get total() {
        return this.price * this.amount
    }
})
```

首先看一下`computed`方法：

```
const computed: IComputed = function computed(arg1, arg2, arg3) {
    if (typeof arg2 === "string") {
        // @computed
        return computedDecorator.apply(null, arguments)
    }
    if (arg1 !== null && typeof arg1 === "object" && arguments.length === 1) {
        // @computed({ options })
        return computedDecorator.apply(null, arguments)
    }

    // computed(expr, options?)
    const opts: IComputedValueOptions<any> = typeof arg2 === "object" ? arg2 : {}
    opts.get = arg1
    opts.set = typeof arg2 === "function" ? arg2 : opts.set
    opts.name = opts.name || arg1.name || "" /* for generated name */

    return new ComputedValue(opts)
}
```

分为三个分支，作为装饰器且不带参数时，执行`computedDecorator`并返回，带参数时也是执行`computedDecorator`后返回；当`computed`用作`computed(expr, options?)`时，返回`new ComputedValue(opts)`。

很明了，先看一下`computedDecorator`做了啥。

其实就调用了`createPropDecorator`函数，第二个参数传入了一个回调函数，回调函数中有我们熟悉的`asObservableObject`，作用是返回`adm`对象，并将`adm`挂在`instance`的`$mobx`属性上，接着调用`addComputedProp`添加`instance`的计算属性。

```
const computedDecorator = createPropDecorator(
    false,
    (
        instance: any,
        propertyName: PropertyKey,
        descriptor: any,
        decoratorTarget: any,
        decoratorArgs: any[]
    ) => {
        const { get, set } = descriptor 
        const options = decoratorArgs[0] || {}
        asObservableObject(instance).addComputedProp(instance, propertyName, {
            get,
            set,
            context: instance,
            ...options
        })
    }
)
```

`addComputedProp`将`computed`装饰的计算属性放入`this.values`中，值为`ComputedValue`类型，`options`中`get`属性在`ComputedValue`中赋值给了`this.derivation`，当计算属性依赖的`observable`变化时，计算属性的值也会重新计算。

最后用`defineProperty`重新定义目标类`target`的计算属性，做一些get、set劫持代理。

前面讲过`this.value`会在`adm`中使用。

`generateComputedPropConfig`重新定义了属性描述符的set、get函数，其实还是调用`adm`的`read`、`write`函数。

```
addComputedProp(
        propertyOwner: any, 
        propName: PropertyKey,
        options: IComputedValueOptions<any>
    ) {
        const { target } = this
        options.name = options.name || `${this.name}.${stringifyKey(propName)}`
        this.values.set(propName, new ComputedValue(options))
        if (propertyOwner === target || isPropertyConfigurable(propertyOwner, propName))
            Object.defineProperty(propertyOwner, propName, generateComputedPropConfig(propName))
    }
```

`createPropDecorator`返回装饰器工厂函数，这个工厂函数执行时返回属性描述符（@computed无参）或一个装饰器函数（@computed({options})有参）。

```
function createPropDecorator(
    propertyInitiallyEnumerable: boolean,
    propertyCreator: PropertyCreator
) {
    return function decoratorFactory() {
        let decoratorArguments: any[]

        const decorator = function decorate(
            target: DecoratorTarget,
            prop: string,
            descriptor: BabelDescriptor | undefined,
            applyImmediately?: any
        ) {
            if (applyImmediately === true) {
                propertyCreator(target, prop, descriptor, target, decoratorArguments)
                return null
            }
            
            if (!Object.prototype.hasOwnProperty.call(target, mobxPendingDecorators)) {
                const inheritedDecorators = target[mobxPendingDecorators]
                addHiddenProp(target, mobxPendingDecorators, { ...inheritedDecorators })
            }
            /**
             * createPropDecorator 传进来的第二个参数，
             * 然后放进了 target[mobxPendingDecorators]![prop] 属性中，
             * 供 initializeInstance 使用
             */
            target[mobxPendingDecorators]![prop] = {
                prop,
                propertyCreator,
                descriptor,
                decoratorTarget: target,
                decoratorArguments
            }
            return createPropertyInitializerDescriptor(prop, propertyInitiallyEnumerable)
        }

        if (quacksLikeADecorator(arguments)) {
            // @decorator 无参数
            decoratorArguments = EMPTY_ARRAY
            // 无参时，返回描述符descriptor（decorator.apply(null, arguments)执行返回描述符）
            return decorator.apply(null, arguments as any)
        } else {
            // @decorator(args) 有参数
            // decoratorArguments在此处赋值，在 decorator 函数中使用（利用闭包）
            decoratorArguments = Array.prototype.slice.call(arguments)
            return decorator
        }
    }
}
```

`createPropertyInitializerDescriptor`缓存了mobx store中定义的属性或方法的描述符，如果没有缓存过则重新生成新的描述符并缓存，新的描述符中`get`、`set`做拦截处理，调用了`initializeInstance`，这个函数只会执行一次，作用是将`target`上的所有属性

```
function createPropertyInitializerDescriptor(
    prop: string,
    enumerable: boolean
): PropertyDescriptor {
    const cache = enumerable ? enumerableDescriptorCache : nonEnumerableDescriptorCache
    return (
        cache[prop] ||
        (cache[prop] = {
            configurable: true,
            enumerable: enumerable,
            get() {
                initializeInstance(this)
                return this[prop]
            },
            set(value) {
                initializeInstance(this)
                this[prop] = value
            }
        })
    )
}
```

`target[mobxPendingDecorators]`是mobx store中所有用`@observable`和`@computed`装饰的属性，即可观察对象和计算属性。这里只讲计算属性，在`initializeInstance`中将这些属性执行一遍`propertyCreator`，即`asObservableObject(instance).addComputedProp(instance, propertyName, {get,set, context: instance,...options})`目的是将属性变为计算值(`computedValue`)，并劫持其set、get操作。

```
function initializeInstance(target: DecoratorTarget) {
    if (target[mobxDidRunLazyInitializersSymbol] === true) return
    
    const decorators = target[mobxPendingDecorators]
    if (decorators) {
        addHiddenProp(target, mobxDidRunLazyInitializersSymbol, true)
        // Build property key array from both strings and symbols
        const keys = [...Object.getOwnPropertySymbols(decorators), ...Object.keys(decorators)]
        for (const key of keys) {
            const d = decorators[key as any]
            d.propertyCreator(target, d.prop, d.descriptor, d.decoratorTarget, d.decoratorArguments)
        }
    }
}
```

接下来我们看`ComputedValue`，`ComputedValue` 同时实现了 `IDerivation` 和`IObservable` 接口，既是观察者又是被观察者，所以它的成员变量是可观察变量和衍生的集合。

先看`get`函数，初始化时走第第一个 if 分支`this.computeValue(false)`传入`false`，那么调用的是`this.derivation.call(this.scope)`，上面讲到过，`this.derivation`就是`@computed`修饰的`get`属性函数，执行这个函数，返回执行后的结果赋值给`this.value`；

第二个分支：首先会`reportObserved(this)`上报自己被观察，把自己放在`derivation`的`newObserving`队列中；接着调用`this.trackAndCompute()`，顾名思义：收集依赖和计算值，收集依赖时调用`this.computeValue(true)`，最终调用的是`trackDerivedFunction(this, this.derivation, this.scope)`，这个函数就很熟悉了吧；如果计算值发生了改变，则调用`propagateChangeConfirmed(observable: IObservable)`，将观察者的依赖状态置为`stale`（`d.dependenciesState = IDerivationState.STALE`）。

```
public get(): T {
        if (this.isComputing) fail(`Cycle detected in computation ${this.name}: ${this.derivation}`)
        // 初始化获取绑定计算属性的依赖关系，或者在 action 中直接获取计算属性
        if (globalState.inBatch === 0 && this.observers.size === 0 && !this.keepAlive) {
            if (shouldCompute(this)) {
                this.warnAboutUntrackedRead()
                startBatch() 
                this.value = this.computeValue(false)
                endBatch()
            }
        } else {
            // reaction.runReaction 处理逻辑中，将进入第二个条件分支
            // ComputedValue 不仅会把自己 reportObserved 给 reaction
            reportObserved(this)
            // 同时自己也是 IDerivation 的派生类，通过 trackAndCompute（里面会调用 trackDerivedFunction）来取值
            // 如果 trackAndCompute 返回 true，即值改变了，向监听自己的 observers 上报 change
            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this)
        }
        const result = this.value!

        if (isCaughtException(result)) throw result.cause
        return result
    }

computeValue(track: boolean) {
        this.isComputing = true
        globalState.computationDepth++
        let res: T | CaughtException
        if (track) {
            res = trackDerivedFunction(this, this.derivation, this.scope)
        } else {
            if (globalState.disableErrorBoundaries === true) {
                res = this.derivation.call(this.scope)
            } else {
                try {
                    res = this.derivation.call(this.scope)
                } catch (e) {
                    res = new CaughtException(e)
                }
            }
        }
        globalState.computationDepth--
        this.isComputing = false
        return res
    }
```

关于计算值，有一个细节：当`computedValue`作为`derivation`,它依赖的`observable`有变更时调用的是`propagateMaybeChanged`，这个方法是在`computedValue`的`onBecomeStale() {propagateMaybeChanged(this)}`使用。

> 调用链路：value changed --> d.onBecomeStale() --> propagateMaybeChanged

先将自己的`lowestObserverState`状态变为`POSSIBLY_STALE`，代表计算值可能会有变更，这个状态只有计算值有，因为计算值的特殊性既是观察者又是被观察者，依赖的对象有变化自己需要感知，同时自己的值一旦有变化，也要通知依赖自己的`observers`，所以这里需要有一个中间状态`可能不稳定`，只有计算值真正改变了才会让`observers`执行动作，是一个很大的性能优化。然后将自己依赖的观察者的状态`dependenciesState`变为`POSSIBLY_STALE`，表示观察者们可能需要重新执行自己的逻辑；那什么时候会将`POSSIBLY_STALE`变为`STALE`呢，需要看`propagateChangeConfirmed`方法了。

```
function propagateMaybeChanged(observable: IObservable) {
    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return
    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE

    observable.observers.forEach(d => {
        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {
            d.dependenciesState = IDerivationState.POSSIBLY_STALE
            if (d.isTracing !== TraceMode.NONE) {
                logTraceInfo(d, observable)
            }
            d.onBecomeStale()
        }
    })
}
```

当一个`derivation`依赖了此`computedValue`，并且执行`runReaction`触发`get`操作时，会走到`propagateChangeConfirmed`中（计算值确实有变更），将状态`POSSIBLY_STALE`变为`STALE`。

```
// ComputedValue 值改变重新计算时调用
function propagateChangeConfirmed(observable: IObservable) {
    if (observable.lowestObserverState === IDerivationState.STALE) return
    observable.lowestObserverState = IDerivationState.STALE

    observable.observers.forEach(d => {
        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE)
            d.dependenciesState = IDerivationState.STALE
        else if (
            // 正在依赖收集阶段
            d.dependenciesState === IDerivationState.UP_TO_DATE
        )
            observable.lowestObserverState = IDerivationState.UP_TO_DATE
    })
}
```

注：引用一段源码中关于`computedValue`实现的注释：

> Implementation description:
>
> 1. First time it's being accessed it will compute and remember result
>
> ​       give back remembered result until 2. happens
>
> 1. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
> 2. When it's being accessed, recompute if any shallow dependency changed.
>
> ​       if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
>
> ​       go to step 2. either way



## Axios拦截器

### 什么是拦截器

拦截器顾名思义就是对请求的拦截，Axios的拦截器有两种，`请求拦截器`和`响应拦截器`，只要为axios实例添加拦截器每个api请求都会执行拦截器。执行顺序: `请求拦截器 -> api请求 -> 响应拦截器`。 使用方式如下

```
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
});
```

拦截器还可以取消， Axios拦截器提供了eject方法取消拦截函数（eject需要传入`id`做为参数，id是个use函数的返回值）

```
const interceptorId = axios.interceptors.request.use(function () {/*...*/}); 
axios.interceptors.request.eject(interceptorId);
```

### axios拦截器的用途

#### 统计请求耗时

有时候我们需要统计api从发起请求到返回数据需要的时间，这种比较集中的逻辑就适合用拦截器来做了，统一处理如果以后要改也非常容易哈。

```
axios.interceptors.request.use((config) => {
  // api请求开始的时间
  config.metadata = { startTime: new Date() }
  return config;
});
axios.interceptors.response.use((res) => {
  // api请求结束的时间
  res.config.metadata.endTime = new Date()
  const { startTime, endTime } = res.config.metadata
  // 计算请求耗时的时间
  console.log(endTime - startTime)
  return res
});
```

#### 响应拦截器对后端状态码拦截

对响应状态码做拦截，比入后端返回404状态码， 跳转到404页面， 也可以做其他状态码的判断(这里就不列举了)

```
axios.interceptors.response.use((res) => {
  return res
}, err => {
  if (err.response.status === 404) {
    router.replace({
      path: '/404.html'
    })
  }
})
```

### 拦截器的思想

一开始很多小伙伴(我自己🐶)会被拦截器这个高大上的名词虎住，以为高大上的名词背后的原理高深莫测的。其实不是的，理解拦截器的思想只需要知道简单的数组操作就好了。 现在我们重新理一下, 请求拦截器发生在api请求之前， 响应拦截器发生在api请求之后，仔细思考🤔一下，其实它们`本质上只是一个执行顺序的关系`。 这其实就是一个数组chain能实现的，把请求拦截器的函数推到数组前面， api请求放在中间， 响应拦截器放在数组后面，遍历执行数组chain就实现了拦截器的执行顺序关系，是不是很简单😄。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3d8f5e7b1a401ca55534f3bf0edd4b~tplv-k3u1fbpfcp-watermark.awebp?)

### 拦截器源码

InterceptorManager构造函数有handlers数组，保存所有的拦截函数， 并且在它的原型上添加三个方法， `use用于添加拦截函数`， 返回一个id， `eject用于取消拦截器`， forEach遍历所有拦截器。

```
// 拦截器构造函数
function InterceptorManager() {
  // 保存拦截器的数组，axios.interceptors.use的拦截函数会被push到handlers，可以添加多个拦截器
  this.handlers = [];
}

// 向拦截器原型上挂载 use方法, 向handler数组中push一个对象, 返回一个id
// 这样就可以通过eject(id) 取消拦截函数了。
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

// 移除拦截器
InterceptorManager.prototype.eject = function eject(id) {
   // 通过id可以查找对应的拦截器，进行移除
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

// 遍历执行所有拦截器
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};
```

请求拦截器和响应拦截器都是使用new InterceptorManager实现

```
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  // 请求拦截器和响应拦截器使用的都是 InterceptorManager构造函数
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
```

`任务编排`, 重点来了(`敲黑板`), 通过 把requestInterceptorChain放在 chain数组的前面，responseInterceptorChain放在chain的后面，然后遍历执行chain（chain数组里的数据是成对出现的，一个是拦截器成功和拦截失败的函数，[dispatchRequest, undefined]中的undefined只起一个`占位`的作用 ）。 达到 请求拦截器 -> api请求 -> 响应拦截器 执行顺序的目的。

```
...
// dispatchRequest是api请求
var chain = [dispatchRequest, undefined];
// 把请求拦截器数组requestInterceptorChain 放在 chain 数组的前面
Array.prototype.unshift.apply(chain, requestInterceptorChain);

// 把响应拦截器responseInterceptorChain 放在chain数组的后面
chain = chain.concat(responseInterceptorChain);

promise = Promise.resolve(config);
// 遍历执行chain函数
while (chain.length) {
  promise = promise.then(chain.shift(), chain.shift());
}
...
```

