
# 网络

### 强缓存 协商缓存

缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。

**强缓存** 

**Expires(HTTP1.0)**：Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。

缺点：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。

**Pragma(HTTP1.0)**：HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓存，Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。服务端响应添加'Pragma': 'no-cache'，浏览器表现行为和刷新(F5)类似。

**Cache-Control(HTTP1.1)**：有很多属性，不同的属性代表的意义也不同：

- private：客户端可以缓存 

- public：客户端和代理服务器都可以缓存 

- max-age=t：缓存内容将在t秒后失效 

- no-cache：需要使用协商缓存来验证缓存数据 

- no-store：所有内容都不会缓存 

请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。当在首部字段Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。命中强缓存的表现形式：Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为200 (from disk cache)或是200 OK (from memory cache)。

**协商缓存** 

协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。

- etag —— if-none-match

- last-modified —— if-modified-since

**Last-Modified**：服务器在响应请求时，会告诉浏览器资源的最后修改时间。

**if-Modified-Since**：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。

- 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK 

- 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified 

**if-Unmodified-Since**: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。

- 如果没有被修改：则开始`继续'传送文件，服务器返回: 200 OK 

- 如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误) 

这两个的区别是一个是修改了才下载一个是没修改才下载。如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

**Etag**：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）（etag比last modified的优先级高）

**If-Match**：条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改

**If-None-Match**： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。

- 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。 

- 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304. 

但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。

- 浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快） 

- F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since 

- Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作 

**缓存场景** 

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 
- 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新 
- 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 

### 前端的一次请求会经过哪些缓存

参考：https://zhuanlan.zhihu.com/p/44789005

#### 缓存的优点：

- 减少了不必要的数据传输，节省带宽
- 减少服务器的负担，提升网站性能
- 加快了客户端加载网页的速度
- 用户体验友好

#### 协商缓存

协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。

#### 缓存位置

- from Service Worker
- from memory cache
- from disk cache
- 真正的网络请求（显示资源的具体大小）

本质是作为服务器与客户端之间的代理服务器，伴随着PWA出现。Service Worker真正意义上将缓存控制权交给了前端，相比于LocalStorage、SessionStorage，后两者只是单纯的接口数据缓存，例如用户信息（一个对象）、列表信息（一个数组），而前者可以缓存静态资源，甚至拦截网络请求，根据网络状况作出不同的缓存策略。
**memory cache**
将资源缓存在了内存中。事实上，所有的网络请求都会被浏览器缓存到内存中，当然，内存容量有限，缓存不能无限存放在内存中，因此，注定是个短期缓存。
内存缓存的控制权在浏览器，前后端都不能干涉。
**disk cache**
将资源缓存在硬盘中，disk cache也叫http cahce，因为其严格遵守http响应头字段来判断哪些资源是否要被缓存，哪些资源是否已经过期。绝大多数缓存都是disk cache。**硬盘缓存的控制权在后端**
disk cahce分为强制缓存与对比缓存。storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的，哈哈哈你们懂得。

localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。

**浏览器支持情况：** 

localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。

### 协商缓存怎么验证是否命中？

参考：https://blog.csdn.net/xingorg/article/details/120426748

## http和https的区别

1. HTTPS协议需要到CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。

2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。

3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

## http

### http头部都有哪些

###### 请求首部字段：

**Accept：**告知服务器，用户代理支持的媒体类型及相对优先级

**Accept-Charset：**告知服务器，用户代理支持的字符集及相对优先级，格式与Accept类似，常应用于服务器驱动协商

**Accept-Encoding：**告知服务器，用户代理支持的内容编码及相对优先级，格式与Accept类似，可指定多种编码

**Accept-Language：**告知服务器，用户代理支持的自然语言及相对优先级，格式与Accept类似

**Authorization**：告知服务器，用户代理的认证信息（证书值），通常在**401 Unauthorized** 响应后将其加入请求头部

**Expect**：告知服务器，期望出现的某种特定行为 
例如在POST大数据时，征询服务器是否能处理，若能，则返回100-continue状态码，否则返回417 Expectation Failed状态码

**From**：告知服务器，使用用户代理的用户电子邮箱地址

**Host**：告知服务器，请求资源所处的互联网主机及端口号 
在Http/1.1中，该字段必须被包含在首部字段中，可设置为空值。常用于区分运行在同一IP之上的多台虚拟主机

**Proxy-Authorization**：与Authorization字段类似，但用于客户端与代理服务器之间，告知代理认证信息

**Range**：用于范围请求，告知服务器请求资源的范围，若处理成功，则返回206 Partial Content响应，否则返回全部资源

**Referer**：告知服务器请求发出来源的URI，可用于查看请求是从哪个Web页面发出的

**User-Agent**：告知服务器，创建请求的浏览器和用户代理名称等信息 
如果请求经过代理，则可能会附加代理服务器的名称

###### 响应请求字段

**Accept-Ranges**：告知客户端，服务器是否能处理范围请求，若能，该字段值为bytes，否则为none

**Age**：告知客户端，源服务器在多久之前创建了该响应。若创建响应的服务器是缓存服务器，则age值代表该缓存从源服务器生成开始经历的时间（秒），当代理创建响应时，该字段必须被加入

**Location**：重定向的URI地址 
该字段会配合3XX Redirection响应，提供重定向的URI地址，几乎所有浏览器在接收到该字段时，都会尝试去访问

**Server**：告知客户端当前服务器上安装的HTTP服务器应用程序信息

**Proxy-Authenticate**：将代理服务器所要求的认证信息发送给客户端

**ETag**：资源标识符 
每个资源都对应着一个唯一的标识符，当资源更新时，标识符也随之更新

- 强ETag值：无论资源实体发生多么细微的变化，该值都会改变

- 弱ETag值：只有资源发生了根本的变化，产生差异时，才会改变值，这时，会在该字段值的前方附加W/


### HTTP请求和TCP链接的对应关系

参考：https://blog.csdn.net/qq_27053493/article/details/102481042

### HTTP1.1中最多支持多少个TCP连接？

一个

参考：https://www.jianshu.com/p/741b324f537c

### HTTP中重定向的方式有几种？

参考：https://blog.csdn.net/qiwoo_weekly/article/details/111189007

参考：https://www.cnblogs.com/ycpanda/p/3637163.html

### 常见http请求方法

HTTP请求的方法：

HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法

![img](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180810112625596-2103906128.png)

 

1、OPTIONS

返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性

2、HEAD

向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。

3、GET

向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url

4、POST

向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form

5、PUT

向指定资源位置上传其最新内容

6、DELETE

请求服务器删除Request-URL所标识的资源

7、TRACE

回显服务器收到的请求，主要用于测试或诊断

8、CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

注意：

1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。

2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。

### HTTP为什么要经过 TIME-WAIT

TIME_WAIT状态存在有两个原因。

1、可靠终止TCP连接。如果最后一个ACK报文因为网络原因被丢弃，此时server因为没有收到ACK而超时重传FIN报文，处于TIME_WAIT状态的client可以继续对FIN报文做回复，向server发送ACK报文。1>

2、保证让迟来的TCP报文段有足够的时间被识别和丢弃。连接结束了，网络中的延迟报文也应该被丢弃掉，以免影响立刻建立的新连接。

### keep-alive

Connection:Keep-alive

HTTP协议采用“请求-应答”模式，不开启KeepAlive模式时，每个req/res客户端和服务端都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当开启Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

### HTTP 劫持

在用户的客户端与其要访问的服务器经过[网络协议](https://baike.baidu.com/item/网络协议/328636)协调后，二者之间建立了一条专用的数据通道，用户端程序在系统中开放指定[网络端口](https://baike.baidu.com/item/网络端口/792237)用于接收数据[报文](https://baike.baidu.com/item/报文/3164352)，服务器端将全部数据按指定网络协议规则进行分解打包，形成连续数据报文。

用户端接收到全部报文后，按照协议标准来[解包](https://baike.baidu.com/item/解包/10871326)组合获得完整的网络数据。其中传输过程中的每一个数据包都有特定的标签，表示其来源、携带的数据属性以及要到何处，所有的数据包经过网络路径中ISP的[路由器](https://baike.baidu.com/item/路由器/108294)传输接力后，最终到达目的地，也就是客户端。

[HTTP](https://baike.baidu.com/item/HTTP)劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的[网络数据](https://baike.baidu.com/item/网络数据/509706)[报文](https://baike.baidu.com/item/报文/3164352)，目的是让用户端程序解释“错误”的数据，并以弹出新窗口的形式在使用者界面展示宣传性广告或者直接显示某网站的内容。

## https

### HTTPS的握手

1、客户端发送“ClientHello”消息，消息包含 SSL 的版本、客户端支持的加密套件和数据压缩算法及随机数1。

2、服务器响应“ServerHello”消息，消息包含选定的加密套件、选定的数据压缩方法、会话标识，数字证书及另一个随机数2。

3、客户端（ Web 浏览器）验证服务器的SSL数字证书的有效性，不通过则提示警告。

4、客户端发送“客户端密钥交换”消息。此消息包含 pre-master secret（用于生成对称加密密钥生的随机数3）。

5、客户端使用一系列加密运算将 [随机数1 随机数2 随机数3] 转化为 master secret，其中将派生出所有用于加密和消息认证的密钥。

6、服务器使用一系列加密运算将 [随机数1 随机数2 随机数3] 转化为 master secret，其中将派生出所有用于加密和消息认证的密钥。

7、客户端发出“更改密码规范”通知服务器端之后使用协商好的对称加密算法及密钥通信。

8、服务器发出“更改密码规范”通知客户端之后使用协商好的对称加密算法及密钥通信。

9、SSL握手结束，使用对称加密算法进行加密通信。

## 介绍下如何实现 token 加密

1. 需要一个secret（随机数）
2. 后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端
3. 前端每次request在header中带上token
4. 后端用同样的算法解密

## 介绍下 HTTPS 中间人攻击

中间人攻击过程如下：

1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密hash值发给服务器。
5. 攻击者获得加密hash值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密hash值，发给服务器。
7. 服务器用私钥解密获得假秘钥。
8. 服务器用加秘钥加密传输信息

防范方法：

1. 服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性

### 数字证书怎么验证真伪？

参考：https://www.cnblogs.com/saolv/p/12912924.html

### 要是https在传公钥的时候被劫持了怎么办？

参考：https://blog.csdn.net/WLQ0621/article/details/112172349


## http2

### http 2.0 特性

相对于HTTP1.0，HTTP1.1的优化：

- 缓存处理：多了Entity tag，If-Unmodified-Since, If-Match, If-None-Match等缓存信息（HTTTP1.0 If-Modified-Since,Expires） 

- 带宽优化及网络连接的使用 

- 错误通知的管理 

- Host头处理 

- 长连接： HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 

相对于HTTP1.1，HTTP2的优化：

- HTTP2支持二进制传送（实现方便且健壮），HTTP1.x是字符串传送 
- HTTP2支持多路复用 
- HTTP2采用HPACK压缩算法压缩头部，减小了传输的体积 
- HTTP2支持服务端推送 

### 服务端推送和长连接有什么区别？

参考：http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html

### http2的多路复用

参考：https://juejin.cn/post/6844903935648497678

参考：https://blog.csdn.net/weixin_41593408/article/details/98022046

### http2的二进制分帧和首部压缩

参考：https://blog.csdn.net/u011904605/article/details/53012844/

### http2中的长连接相比于http1中手动指定keep-alive的优势

参考：https://blog.csdn.net/weixin_37672169/article/details/80283935



## http3

**1.HTTP/3简介**

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。

上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。

因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

**Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上**，HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。

**2.QUIC新功能**

- 0-RTT

通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。**0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势**。那什么是 0RTT 建连呢？

这里面有两层含义:

1.传输层 0RTT 就能建立连接。

2.加密层 0RTT 就能建立加密连接。

![img](http://5b0988e595225.cdn.sohucs.com/images/20190305/89ac5d6c6b4a408b8f86e078441ee430.jpeg)

上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是会话复用也需要至少 2 个 RTT。

而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高很多。

- 多路复用

虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。

同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。比如下图中stream2丢了一个UDP包，不会影响后面跟着 Stream3 和 Stream4，不存在 TCP 队头阻塞。虽然stream2的那个包需要重新传，但是stream3、stream4的包无需等待，就可以发给用户。

![img](http://5b0988e595225.cdn.sohucs.com/images/20190305/d61228860d9c48d182a0274cf09f051f.jpeg)

另外QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。

- 加密认证的报文

TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。

但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。

这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。

![img](http://5b0988e595225.cdn.sohucs.com/images/20190305/986f23e92daa4a95bcf9622b5892bee2.jpeg)

如上图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。

- 向前纠错机制

QUIC协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。

假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。**当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了**。

## http状态码

1开头的http状态码
表示临时响应并需要请求者继续执行操作的状态代码。

100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  
101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。

2开头的http状态码
表示请求成功

200     成功处理了请求，一般情况下都是返回此状态码； 
201     请求成功并且服务器创建了新的资源。 
202     接受请求但没创建资源； 
203     返回另一资源的请求； 
204     服务器成功处理了请求，但没有返回任何内容；
205     服务器成功处理了请求，但没有返回任何内容；
206     处理部分请求；

3xx （重定向） 
重定向代码，也是常见的代码

300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 
302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 
303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 
304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 
305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。


4开头的http状态码表示请求出错

400    服务器不理解请求的语法。 
401   请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
403   服务器拒绝请求。 
404   服务器找不到请求的网页。 
405   禁用请求中指定的方法。 
406   无法使用请求的内容特性响应请求的网页。 
407   此状态代码与 401类似，但指定请求者应当授权使用代理。 
408   服务器等候请求时发生超时。 
409   服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 
410   如果请求的资源已永久删除，服务器就会返回此响应。 
411   服务器不接受不含有效内容长度标头字段的请求。 
412   服务器未满足请求者在请求中设置的其中一个前提条件。 
413   服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
414   请求的 URI（通常为网址）过长，服务器无法处理。 
415   请求的格式不受请求页面的支持。 
416   如果页面无法提供请求的范围，则服务器会返回此状态代码。 
417   服务器未满足”期望”请求标头字段的要求。


5开头状态码并不常见，但是我们应该知道

500   （服务器内部错误）  服务器遇到错误，无法完成请求。 
501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 
502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 
504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

## osi模型 

[物理层](https://baike.baidu.com/item/物理层): 将数据转换为可通过物理介质传送的[电子信号](https://baike.baidu.com/item/电子信号) 相当于邮局中的搬运工人。

[数据链路层](https://baike.baidu.com/item/数据链路层): 决定访问网络介质的方式。

在此层将数据分帧，并处理流控制。本层指定[拓扑结构](https://baike.baidu.com/item/拓扑结构)并提供硬件寻址，相当于邮局中的装拆箱工人。

[网络层](https://baike.baidu.com/item/网络层/4329439): 使用权数据路由经过大型网络 相当于邮局中的排序工人。

[传输层](https://baike.baidu.com/item/传输层): 提供终端到终端的可靠连接 相当于公司中跑邮局的送信职员。

[会话层](https://baike.baidu.com/item/会话层): 允许用户使用简单易记的名称建立连接 相当于公司中收寄信、写信封与拆信封的秘书。

[表示层](https://baike.baidu.com/item/表示层): 协商数据交换格式 相当公司中简报老板、替老板写信的助理。

[应用层](https://baike.baidu.com/item/应用层/4329788): 用户的应用程序和网络之间的接口。

## 路由器工作在哪一层 

网络层

## http协议，ssl工作在哪一层 

传输层

## 绝对链接与相对链接

要尽可能的使用相对链接

1.检查代码，相对URL会更加有效，因为相对URL一般会比绝对URL短的多。

2.使用绝对URL的时候，浏览器会先通过DNS查找服务器的真实位置，然后再转到该服务器并查找所请求的文件。

相对URL只会在同一服务器上查找被请求的文件。

### **长轮询和短轮询是什么？**

【2.1】http 长轮询
1）介绍：http 长轮询是server 收到请求后如果有数据，立刻响应请求；如果没有数据 就会 停留 一段时间，这段时间内，如果 server 请求的数据到达（如查询数据库或数据的逻辑处理完成），就会立刻响应；如果这段时间过后，还没有数据到达，则以空数据的形式响应http请求；若浏览器收到的数据为空，会再次发送同样的http请求到server；
2）http 长轮询 的缺点：server 没有数据到达时，http连接会停留一段时间，这会造成服务器资源浪费；
3）看个荔枝：假设有 1000个人停留在某个客户端页面，等待server端的数据更新，那就很有可能服务器这边挂着1000个线程，在不停检测数据是否发生变化，这依然是有问题的；

【2.2】http 短轮询
1）介绍：http 短轮询是 server 收到请求 不管是否有数据到达都直接响应http 请求；如果浏览器收到的数据为空，则隔一段时间，浏览器又会发送相同的http请求到server 以获取数据响应；
2） http 短轮询的缺点：消息交互的实时性较低（server端到浏览器端的数据反馈效率低）；

【2.3】http 长轮询 和 短轮询的异同
1）相同点：当server 的数据不可达时，基于http长轮询和短轮询 的http请求，都会 停留一段时间；
2）不同点：http长轮询是在服务器端的停留，而http 短轮询是在 浏览器端的停留；
3）性能总结：从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满；

## DNS

DNS解析的时候可以使用DNS缓存去减少重复操作，DNS缓存有浏览器DNS缓存、系统DNS缓存、路由DNS缓存、服务商DNS缓存。

DNS有两种查询的方式，分为递归查询和迭代查询。递归查询是访问根域名服务器，根域名服务器层层下发，找到目标域名的IP地址后返回。迭代查询是访问根域名服务器后，根域名服务器返回一个其他DNS服务器的地址，然后再向其他DNS服务器去查询。

**DNS缓存**

在浏览器中输入URL的时候，DNS会根据域名找到对应的IP地址。在DNS查找目标域名对应的IP地址的时候，首先会去访问浏览器缓存，看最近访问的网址中有没有目标域名，如果没有则会访问系统DNS缓存中的是否存在，依旧不存在则会去路由缓存中查找，但是还是不存在的话就会去ISP服务商的缓存中查找是否有目标域名的IP地址。如果缓存中都不存在则会访问根域名服务器去查找目标域名的IP地址，根域名服务器会层层下发直到找到对应域名的IP地址为止。

### DNS解析过程？

首先检查浏览器缓存中以及操作系统缓存中有没有对应的已解析过的结果（hosts文件），若没有则请求本地域名服务器（LDNS）来解析这个域名，若未成功解析，则跳转到根域名服务器，根域名服务器给予一个主域名服务器地址，然后本地域名服务器再去请求主域名服务器地址，接着主域名服务器会返回网站注册域名的服务器Name server的地址，本地服务器又去访问Name server，最终找到ip地址并返回给本地域名服务器，然后缓存该ip地址，解析结束。

### DNS预解析的原理？哪部分最耗时？

参考：https://blog.csdn.net/weixin_42370640/article/details/106174842

## websocket

WebSocket 是除最初建立连接时需要借助于现有的HTTP协议，其他时候直接基于TCP完成通信。它可以让我们在客户端和服务器之间以数据流的形式实现各种应用数据交换（包括JSON 及自定义的二进制消息格式），而且两端都可以随时向另一端发送数据。

- 连接协商和同源策略；
- 与既有 HTTP 基础设施的互操作；
- 基于消息的通信和高效消息分帧；
- 子协议协商及可扩展能力。

### websocket和长连接区别

- 长连接、

连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。

长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

WebSocket优势： 浏览器和服务器只需要要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息。同时，服务器与客户端之间交换的头信息很小。

HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。这种长连接是一种“伪链接”

websocket的长连接，是一个真的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。

### websocket详解

WebSocket连接的建立只有两步：

1. Client发送一个 ‘upgrade' request，这是一个http请求，使用的是http协议。
2. Server返回一个http 101，代表请求成功。

接下来双方就开始使用WebSocket 协议相互通讯了，不再使用http协议了。

下面这张图就是上面着两步的图示。

![img](https://img2020.cnblogs.com/blog/2013920/202012/2013920-20201223214958395-1590758811.png)

 

 

下面这张图是完整的过程

![img](https://img2020.cnblogs.com/blog/2013920/202012/2013920-20201223215108365-546475956.png)

 

 

下面这张图展示了“拟人化”的从http协议升级到websoket协议的协商过程

![img](https://img2020.cnblogs.com/blog/2013920/202012/2013920-20201223215255287-541610540.png)

 

### 服务器推送和 websocket 区别? 热模块替换原理?

参考：https://www.cnblogs.com/frank-link/p/14838760.html

参考：https://blog.csdn.net/chainhou/article/details/112686828



## 三次握手和四次挥手

在创建连接时，

1.客户端首先要SYN=1,表示要创建连接，

2.服务端接收到后，要告诉客户端：我接受到了！所以加个ACK=1，就变成了ACK=1,SYN=1

3.理论上这时就创建连接成功了，但是要防止一个意外（见疑问三），所以客户端要再发一个消息给服务端确认一下，这时只需要ACK=1就行了。

三次握手完成！

在四次分手时，

1.首先客户端请求关闭客户端到服务端方向的连接，这时客户端就要发送一个FIN=1，表示要关闭一个方向的连接（见上面四次分手的图）

2.服务端接收到后是需要确认一下的，所以返回了一个ACK=1

3.这时只关闭了一个方向，另一个方向也需要关闭，所以服务端也向客户端发了一个FIN=1 ACK=1

4.客户端接收到后发送ACK=1，表示接受成功

四次分手完成！

### **HTTP为什么需要三次握手**

如果发送两次就可以建立连接话，那么只要客户端发送一个连接请求，服务端接收到并发送了确认，就会建立一个连接。

**可能出现的问题：**如果一个连接请求在网络中跑的慢，超时了，这时客户端会从发请求，但是这个跑的慢的请求最后还是跑到了，然后服务端就接收了两个连接请求，然后全部回应就会创建两个连接，浪费资源！

如果加了第三次客户端确认，客户端在接受到一个服务端连接确认请求后，后面再接收到的连接确认请求就可以抛弃不管了。

### **HTTP为什么需要四次分手**

TCP是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。



## TCP 与 UDP

### TCP和UDP的区别

（1）**TCP是面向连接的；UDP是无连接的**，即发送数据前不需要先建立链接

（2）**TCP提供可靠的服务**，通过TCP连接传输的数据无差错、不丢失、不重复，且按序到达，适合大数据量的交换；**UDP尽最大努力交付**，但不保证可靠

（3）**TCP是面向字节流；UDP面向报文**，并且网络出现拥塞不会使发送速率降低（会出现丢包，比如IP电话或者视频会议）

（4）**TCP只能端对端；UDP支持1对1 、1对多**

（5）**TCP的首部较大，为20字节；UDP为8字节**

### tcp和udp的应用举例

TCP应用：

FTP：文件传输协议
SSH：安全登录、文件传送（SCP）和端口重定向
Telnet：不安全文本传送
SMTP：简单邮件传输协议
HTTP：超文本传输协议
UDP应用：

流媒体

如果采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议入WebRTC使极佳的选择。

实时游戏

对实时要求较为严格的情况下，采用自定义的可靠UDP协议，自定义重传策略，能哦把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。

原文链接：https://blog.csdn.net/weixin_43784305/article/details/104918771

### 泛洪攻击

SYN攻击利用的是[TCP](https://baike.baidu.com/item/TCP)的[三次握手](https://baike.baidu.com/item/三次握手/5111559)机制，攻击端利用伪造的[IP](https://baike.baidu.com/item/IP)地址向被攻击端发出请求，而被攻击端发出的响应 [报文](https://baike.baidu.com/item/报文/3164352)将永远发送不到目的地，那么被攻击端在等待关闭这个连接的过程中消耗了资源，如果有成千上万的这种连接，[主机](https://baike.baidu.com/item/主机/455151)资源将被耗尽，从而达到攻击的目的。

### TCP拥塞处理

参考：https://blog.csdn.net/qq_41431406/article/details/97926927

### TCP滑动窗口

参考：https://www.cnblogs.com/luoquan/p/4886345.html

### TCP粘包问题

参考：https://www.cnblogs.com/kex1n/p/6502002.html

### TCP和HTTP的区别和联系

参考：https://blog.csdn.net/qq_31332467/article/details/79217262

## 网络的五层模型

![img](https://upload-images.jianshu.io/upload_images/13548275-88019f07df712ac2.png?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)


## get与post

### get、post的区别？

- Get 请求能缓存，Post 不能

- Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。

- Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术

- URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的

- Post 支持更多的编码类型且不对数据类型限制

## 简单请求和非简单请求?

参考：https://www.jianshu.com/p/782b16c3e172


## DOS、 DDOS攻击原理和防范

参考：https://blog.csdn.net/pygain/article/details/52134480

## XSS是什么，怎么预防

**XSS（跨站脚本攻击）** 

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。会将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

**XSS攻击防范** 

**HttpOnly 防止劫取 Cookie**：浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，**HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。**

**输入、输出检查**：不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 <，> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <，>，script，防止 XSS 攻击：

**CSRF/XSRF（跨站请求伪造）** 

CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。

**CSRF攻击防范** 

**验证码**：验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。

**Referer Check**：根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。

**添加token验证**：要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

## 介绍一下CDN

### 谈一谈对CDN的理解

(1)节省骨干网带宽，减少带宽需求量；

(2)提供服务器端加速，解决由于用户访问量大造成的服务器过载问题； 

(3)服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求； 

(4)能克服网站分布不均的问题，并且能降低网站自身建设和维护成本； 

(5)降低“通信风暴”的影响，提高网络访问的稳定性。 

### CDN原理

给源站域名添加CNMAE,别名为加速节点的域名。当用户向源站发起请求时，dns服务器解析源站域名时会发现有CNMAE记录，这时dns服务器会向CNAME域名发起请求，请求会被调度至加速节点的域名。

### CDN缓存

和Http类似，客户端请求数据时，先从本地缓存查找，如果被请求数据没有过期，拿过来用，如果过期，就向CDN边缘节点发起请求。CDN便会检测被请求的数据是否过期，如果没有过期，就返回数据给客户端，如果过期，CDN再向源站发送请求获取新数据。和买家买货，卖家没货，卖家再进货一个道理^^。

​    CDN边缘节点缓存机制，一般都遵守http标准协议，通过http响应头中的Cache-Control和max-age的字段来设置CDN边缘节点的数据缓存时间。

### CDN回源策略

在搜索引擎中所谓的域名回源就是搜索引擎的蜘蛛在爬行的过程中直接抓取源地址上的内容而不是存在各个节点（CDN）上的缓存内容。

## 知道数字签名和数字信封吗？

### 数字签名

定义
用户用自己的【私钥】对原始数据的哈希摘要进行加密所得的数据。

原理
用户A将待发送的信息原文经散列函数运算生成摘要信息，并用自己的私有密钥对摘要信息进行加密，将形成的密文和原文传送给用户B。用户B接收到密文后，使用A的公开密钥验证密文，得到摘要信息，并按照约定的摘要算法对原文进行摘要运算，再将两个摘要值进行比对，一致则表明数据未被篡改。

作用
对用户的身份认证，保证了数据在传输过程中的完整性、和交易的不可否认性；

签名种类
P7签名又分为两类：
Attached签名
将原文数据、签名证书、签名证书算法、签名数据封装成签名数据。因此，在验签的时候只提供签名结果就可以。

Detached签名
将签名证书、签名算法、签名数据封装成签名数据。注：没有原文信息，因此，在验签的时候不光提供签名结果，还要提供明文。

P1签名也称为裸签
只包含纯碎的签名结果。因此，在验签的时候，提供签名结果，提供明文和签名证书三种数据。

验证签名
验签的原理
用加签相通的hash算法得到摘要A，然后根据公钥对签名结果解密得到摘要B。对比摘要A和摘要B是否相通。

### 数字信封

定义
是将对称密钥通过非对称加密(即:有公钥和私钥两个)的结果分发对称密钥的方法。数字信封是实现信息完整性验证的技术。

原理
首先，用户A使用由计算机随机生成的一组一次使用的对称密钥——会话密钥（Session Key）加密信息原文，形成密文，然后使用用户B的公开密钥对会话密钥进行加密，并将加密的会话密钥附在密文后一起发送给用户B；用户B在接收到密文和加密的会话密钥后，先用自己对应的私钥解密得出会话密钥，然后再用会话密钥解密密文，最终获得信息原文


作用
用户传输数据的。因为对称加密的处理性能比非对称加密要快，所以这样可以提高了服务的性能。再用非对称加密对对称密钥加密，这样保证了数据的安全性。

签名 、数字信封、证书的关系
三者没有任何的关系！！三者没有任何的关系！！三者没有任何的关系！！他们三个的作用是不同的。
签名：是为了验证身份的；
信封：是为了传输信息的；
证书：是承载公钥和发布者一些信息的。


## restful api理解

参考：http://www.ruanyifeng.com/blog/2014/05/restful_api.html

## sql注入原理及防范

参考：https://www.cnblogs.com/wugu-ren/p/6816306.html

## 用户登录认证过程

参考：https://blog.csdn.net/weixin_44421461/article/details/122295322

## 登录持久化怎么实现的?

JWT：https://blog.csdn.net/weixin_45070175/article/details/118559272

cookie：https://www.jianshu.com/p/6fc9cea6daa2

## cookie

下图是Chrome浏览器中的Cookie截图，属性分别有Name、Value、Domain、Path、Expires/Max-age、Size、HttpOnly、Secure、SameSite和Priority。

 ![浏览器中的Cookie](https://img-blog.csdnimg.cn/20200805102311919.png)

### Name和Value

Name和Value是一个键值对。Name是Cookie的名称，Cookie一旦创建，名称便不可更改，一般名称不区分大小写；Value是该名称对应的Cookie的值，如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。 

### Domain

Domain决定Cookie在哪个域是有效的，也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Doamin设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(".")开始。

### Path

Path是Cookie的有效路径，和Domain类似，也对子路径生效，如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 /b/,而Cookie的Path为 /b/c/,则在a.com/b页面时只可以访问Cookie1，在a.com/b/c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“/”结尾。

### Expires/Max-age

Expires和Max-age均为Cookie的有效期，Expires是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不设置则默认页面关闭时删除该Cookie。
Max-age也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0，则立刻失效，设置为负数，则在页面关闭时失效。Max-age默认为 -1。

### Size

Szie是此Cookie的大小。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。各个浏览器对Cookie的最大值和最大数目有不同的限制，整理为下表(数据来源网络，未测试)：

| 浏览器  | Cookie最大条数 | Cookie最大长度/单位：字节 |
| ------- | -------------- | ------------------------- |
| IE      | 50             | 4095                      |
| Chrome  | 150            | 4096                      |
| FireFox | 50             | 4097                      |
| Opera   | 30             | 4096                      |
| Safari  | 无限           | 4097                      |

### HttpOnly

HttpOnly值为 true 或 false,若设置为true，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。 

### Secure

Secure为Cookie的安全属性，若设置为true，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。

### SameSite

SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：

Strict
Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie

Lax
Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

None
网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

资料借鉴来源:Cookie 的 SameSite属性——阮一峰

关闭SameSite的方法

操作方法谷歌浏览器地址栏输入：chrome://flags/
找到：SameSite by default cookies、Cookies without SameSite must be secure设置上面这两项设置成 Disable

### Priority

优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。
在360极速浏览器和FireFox中，不存在Priority属性，不清楚在此类浏览器中设置该属性后是否生效。

FireFox浏览器的Cookie

![FireFox](https://img-blog.csdnimg.cn/20200805171202619.png)

360极速浏览器的Cookie

![360极速浏览器](https://img-blog.csdnimg.cn/2020080517050835.png)



### Session相关

参考：https://blog.csdn.net/londa/article/details/94838127?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6.pc_relevant_default&utm_relevant_index=11

### cookie session 怎么实现保留登录状态的，服务端客户端都怎么写的

参考：https://www.cnblogs.com/BOHB-yunying/p/10853185.html

参考：https://blog.csdn.net/qq_35181209/article/details/77488663?fps=1&locationNum=10

参考：https://www.cnblogs.com/ruiser/p/5687249.html

参考：https://juejin.cn/post/6844904142155022349

