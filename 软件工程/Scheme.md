### Scheme十诫

#### 第一诫

当对一个原子列表lat进行递归调用时，询问两个关于lat的问题:(null ? lat) 和 else

当对一个数字n进行递归调用时，询问两个有关n的问题: (zero ? n) 和 else

当对一个S-表达式列表l进行递归调用时，询问三个有关l的问题:(null? lat)\(atom? (car l)) 和else

#### 第二诫

使用cons来构建列表

#### 第三诫

构建一个列表的时候，描述第一个典型元素，之后cons该元素到一般性递归上。

#### 第四诫

在递归时总是改变至少一个参数。当对一个原子列表lat进行递归调用时，使用(cdr lat)。当对数字n进行递归调用时，使用时(subl n)。当对一个S-表达式l进行递归调用时，只要是(null? l)和(atom? (car l))都不为true,那么就同时使用(car l)和(cdr l)。

在递归时改变的参数，必须向这不断接近结束条件而改变。改变的参数必须在结束条件中得以测试:

当使用cdr时，用null?测试是否结束;

当使用subl时，用zero?测试是否结束;

#### 第五诫

当用+构建一个值时，总是使用0作为结束代码行的值，因为加上0不会改变加法的值。

当用x构建一个值时，总是使用1作为结束代码行的值，因为乘以1不会改变乘法的值。

当用cons构建一个值时，总是考虑把0作为结束代码行的值

#### 第六诫

简化工作只在功能正确之后开展。

#### 第七诫

对具有相同性质的subparts(子部件)进行递归调用:

1.列表的子列表

2.算数表达式的子表达式

#### 第八诫

使用辅助函数来抽象表达式。

#### 第九诫

用函数来抽象通用模式

#### 第十诫

构建函数，一次收集多个值。

### Scheme五法

#### car之法则

基本元件car仅定义为针对非空列表。

car 取列表第一个

#### cdr之法则

基本元件cdr仅定义为针对非空列表。任意非空列表的cdr总是另一个列表。

cdr 取列表剩下的（除去列表的第一个）

#### cons之法则

基本元件cons需要两个参数。第二个参数必须是一个列表。结果是一个列表。

往列表中添加参数

#### Null?之法则

基本元件null?仅定义为针对列表

是否为空列表

#### eq?之法则

基本元件eq?需要两个参数。每个参数都必须是一个非数字的原子。

是否相等

lat函数：检验函数是否不包含列表

cond... 问问题

lambda...创建一个函数

define... 为函数命名

or...询问两个问题，一次问一个。如果对一个问题为true，则停止问第二个问题，答案为true。否则继续询问第二个问题，答案为第二个问题的应答。

rember 代表移除一个成员
(quote())是空列表的记法
